=================== LEXER ===================

used:
!%&()*+,-.:;<=>?^[]{}|

not used:
$'@\`~

//comment
/*ml comment*/

#directive

"string"


&& || == >= <= != .. ---
>> << ->
+= -= *= /= ^= &= |= %=


=================== PARSER ===================

module : #import string
       | declaration*

declaration : identifier ':' [expression] ((':' | '=') expression | ';')

expression : '(' expression ')'
		   | '(' identifier ':' expression [',' identifier ':' expression]* ')' ['->' []] [statement]
           | expression binaryop expression
           | unaryop expression
		   | expression '(' expression [',' expression]* ')'

statement : declaration
          | 'ret' expression ';'
		  | expression '=' expression ';'
		  | 'if' expression statement
		  | 'for' expression statement
		  | 'defer' statement
		  | '{' statement* '}'


=================== ERROR MESSAGES ===================

file:line_number -> error_type: what
    |
 ln | source code
    |        ^~~~ context
    |
scripts/main.kai:4 -> Syntax Error: Unexpected ";"
   |
 4 | what *;
   |       ^ expected an expression here


scripts/main.kai:12 -> Type Cast Error: Cannot implicitly cast from "u64" to "What"
    |
 12 | var : What = filesize;
    |              ^~~~~~~~ consider using a cast() here
scripts/main.kai:432 -> Info: "What" is defined here
     |
 432 | What :: struct {
     | ^~~~


=================== NUMBER PARSER ===================

basic integer:    19845
binary:           0b0110110101
hexidecimal:      0xfe42
with separators:  12_000_000
basic float:      3.1415
float with exp:   1.0e-10

#infinity
#nan

number : u16 = 100_000; // Type Cast Error: 100000 cannot be represented in data format "u16"

scripts/main.kai:12 -> Type Cast Error: Cannot implicitly cast from "number" to "What"



loop {  }
while x < 3 {  }
for 0..n-1 {  }

コールバックを
さまざまなプログラミング言語へのDyncallバインディングは、パブリックにアクセス可能な水銀リポジトリでホストされます。チェックアウトするには、
HGクローン https://dyncall.org/pub/dyncall/bindings/
以下は、リポジトリ内のdyncallバインディングに関するクイック情報のリストです。ショーケース/ユーザーでFFIの実装にdyncallを使用するその他のプロジェクトを参照してください。

// circular dependency
A :: B;
B :: A;

=================== NUMBER INFO -> FLOATING POINT ===================

Forward + Reverse mode autodiff ???
/*
d_fibonacci :: #forward_diff (x: $T) -> T {
    if n <= 2 ret 1;
    ret fibonacci(n-2) + fibonacci(n-1);
}

d_fibonacci :: (x: #diff_type($T)) -> #diff_type(T) {
    if n <= 2 ret {1, 0};
    ret d_fibonacci({n-2, x.dif}) + d_fibonacci({n-1, x.dif});
}
*/


void __branching_examples() {
    int EXPR;
    // if (EXPR) { A } else { B }
    if (~EXPR) goto else__2;
    {
        // A
    }
    goto endif__2;
else__2:
    {
        // B
    }
endif__2:
    // BYTECODE_OP_COMPARE
    // BYTECODE_OP_BRANCH
    // ...
    // BYTECODE_OP_JUMP
    // ...

    // while (EXPR) { A }
while__0:
    if (~EXPR) goto endwhile__0;
    {
        // A
    }
    goto while__0;
endwhile__0:
    // BYTECODE_OP_COMPARE
    // BYTECODE_OP_BRANCH
    // ...
    // BYTECODE_OP_JUMP
    (void)0;
}



TYPES:


void, bool, type,
u8, u16, u32, u64,
s8, s16, s32, s64,
f32, f64,

int, uint, // same size as *void

Raw_Slice :: struct ($T: type) {
	count: uint;
	data:  *T;
}
// [] T

