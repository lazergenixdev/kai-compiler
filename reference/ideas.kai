
// Idea: functions that will automatically insert their first argument
//         by searching for a matching identifier in the local scope
example :: ()
{
    Allocator :: struct {}
    allocate :: (allocator: Allocator, size: u32) { ret null; }

    allocator: Allocator = get_allocator();

    // this
    memory := allocate!(100);

    // is same as this
    memory := allocate(allocator, 100);
}

// Idea: Do tagged unions like in Odin?
example :: ()
{
    Value :: union { u32, f32 };

    value: Value = 56->u32;

    if value == {
        case u32; {
            println("got u32");
        }
        case f32; {
            println("got f32");
        }
    }
}

// Idea: Expand matrix type to be generic multidimensional array
example :: ()
{
    mat: [4,4] f32;
    last := mat[3,3];

    generic: [3,4,10,2] f32;
    last := generic[2,3,9,1];
}

// Idea: Assigning multiple return values to multiple declarations.
example :: ()
{
    f1 :: () -> A {}
    f2 :: () -> B, C {}
    f3 :: () -> D, E, F {}

    // a: A, b: B, c: C
    a, b, c := f1(), f2();

    d, e, f, b, c := f3(), f2();

    d := f1(), f1(); // ERROR: cannot have more values than declarations.

    // ~~~ each name can have a type? ~~~
    a: u32, b: f32 = 10, 20;

    // do same as argument list?
    a, b: f32 = 10, 20; // #type(a) = #type(b)
}

example :: ()
{
    for ptr: head..tail {...}
    // same as
    //for (List* p = head; head != tail; p->next)
}

// Idea: multiline string
//        start = "\"\"\"\n", end = "\n\"\"\""
example :: ()
{
	document: string = 
"""
Multi line string literal
	- yes?
	- no?
""";
	empty ::
	"""
	"""
	
	oneLine ::
"""

"""
}

// Idea: ability to tag any piece of code (== notes in Jai)
//       (useful for codegen and also reflection)
example :: ()
{
    // {} to parse as a statement, () to parse as a function call
    Bus :: struct {
        passengers: *Person; @size(count)
        count: u32;
        name: string; @format(width = 24)
    }
    @contructor {
        create_bus :: () -> Bus {
            ret Bus.{};
        }
    }

    // Now the host program could modify the syntax tree
    // to call `create_bus` as a default contructor
    bus: Bus;

    // More useful examples
    Properties :: struct {
        max: f32; @widget(type = "slider", min = 0, max = 123)
        frame_limit: u32; @const
        iterations: u32; @widget(type = "slider", name="i")
    }

    value: u64 = 0x45; @static
    ret *value;

    // Note to self:
    // In Parser: look for '(' -> parse inside as function call
    //            look for '{' -> parse as statement
    //            else no expression associated with tag
    // In CodeGen: tag values should be compile time constants,
    //             making them runtime values does not make any sense semantically
}
@doc_short ("Example function thing")
@doc_long (
"""
More detailed description of the function
"""
)

// Idea: Hash table syntax
example :: ()
{
    // if inside the brackets '[]' there is type 'string'
    // then the type becomes a hash table
    table: [string] int;

    table.count; // get number of elements
    table_set(*table, "this", 123); // sets value of element, overwriting previous value
    table_find(*table, "this"); // get index of element, or -1 if not found
    table_get(*table, "this"); // get element, or -1 if not found
    table_remove(*table, "this"); // deletes entry
    table_destroy(*table); // free memory
}

// Idea: Distinct directive or keyword?
example :: ()
{
    //BigInt :: distinct int;
    BigInt :: #distinct int;
}

// Idea: ternary op
example :: ()
{
    x := 2;
    y := 4 if x < 3 else 2;
}

// (Library)
// Idea: Store bit mask of what is stored on each AST node
example :: ()
{
    Ast :: struct {
        id:     u8;
        fields: u16;
        name:   string; // only present if fields & 0x0001
        next:   *Ast;   // only present if fields & 0x0002
        // ...
    }

    // This is a serialization problem!

    Declaration :: struct {
        id:   u8;
        mask: u16;
        name: string;
        type: *Expr; @opt(mask, 0)
        expr: *Expr; @opt(mask, 1)
    }

    serial :: #import "Serialize/Binary"

    data: [#size(Declaration)] u8;
    object: Declaration;
    bytes_wrote := serial.serialize(data, 0, object);

    objcopy := serial.deserialize(data, 0, #type(object));
}

// Idea: Procedures that can only be accessed within the file
//        they are defined (same as Jai file_scope)
#internal
example :: (a: u64, b: u32) -> f32
{
    ret (a - 1)->f32 + b->f32;
}

// Idea: New operators for bit flags, bit sets
example :: (a: u64, b: u32) -> f32
{
    flags := 0b001010010110;
    bits  := 0b001010000000;

    flags &* bits; // check any of bits are set
    flags & bits; // check all bits are set
    flags | bits; // union

    bits in flags; // all bits in bits are set in flags

    // ???
    // && -> and
    // || -> or
    if flags == 0 or flags == 1 then
        ret 0;
}

// Idea: NO null value, no raw pointers
example :: ()
{
    // union is a problem
    union {
        name: [..] u32;

        value: struct {
            pointer:  u64;
            count:    u32;
            capacity: u32;
        };
    };

    // solutions?:
    // -> union is tagged, cannot change tag without changing the value

    // tree structures are a problem
    // -> no, just use arrays and store index's NOT pointers

    // main issue: performance
    arr: [..] u32;
    initialize(*arr);

    for i: some_number {
        // need to bounds check for every call!
        sum += arr[f(i)];
    }
}


// NOTES SECTION

// There are some ambiguities in the language
// where `[expression]` looks like a dereference,
// and `() -> int` looks like a procedure declaration.
// So if you want to get an array type, hash table type,
// or procedure type, then you need to put an extra directive
// in-front to tell the parser that you want a type as an expression
array      :: #array [3] int;
hash_table :: #map [string] int;
proc       :: #proc () -> int;

[string] (); // map of functions, or dereference string an call

// These expressions will work as expected because
array :: [] int;   // `[]` is not a valid expression
array :: [..] int; // `[..]` is also not a valid expression

// Too soon to think about macros
macro :: (code: #Code, expr: #Code) #expand {
    expr = code;
}
