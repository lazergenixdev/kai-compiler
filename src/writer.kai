#import "stdio.h";
#import "locale.h";

_term_debug_colors: [7] cstring = .{
    "\x1b[0m",    // KAI_COLOR_DEFAULT
    "\x1b[1;97m", // KAI_COLOR_PRIMARY
    "\x1b[1;96m", // KAI_COLOR_SPECIAL   
    "\x1b[1;91m", // KAI_COLOR_IMPORTANT   
    "\x1b[1;94m", // KAI_COLOR_VARIABLE
    "\x1b[0;90m", // KAI_COLOR_DECORATION
    "\x1b[0;92m", // KAI_COLOR_TYPE
};

_file_writer_write :: (user: *void, command: Write_Command, value: Value, format: Write_Format)
{
    // TODO: need to properly handle min_count and fill_character   
    if user == null ret;
    f: *FILE = cast user;
    if command & 0x80 {
        fprintf(f, "%s", _term_debug_colors[command & 0x7F]);
        ret;
    }
    if command == {
        case KAI_WRITE_STRING; {
            fwrite(value.string.data, 1, value.string.count, f);
        }
        case KAI_WRITE_U8; {
            value.u64 = value.u8 -> u64;
        } #through;
        case KAI_WRITE_U16; {
            value.u64 = value.u16 -> u64;
        } #through;
        case KAI_WRITE_U32; {
            value.u64 = value.u32 -> u64;
        } #through;
        case KAI_WRITE_U64; {
            if (format.min_count == 0)
                fprintf(f, "%llu", value.u64);
            else
                fprintf(f, "%016llu", value.u64);
        }
        case KAI_WRITE_S8; {
            value.s64 = value.s8 -> s64;
        } #through;
        case KAI_WRITE_S16; {
            value.s64 = value.s16 -> s64;
        } #through;
        case KAI_WRITE_S32; {
            value.s64 = value.s32 -> s64;
        } #through;
        case KAI_WRITE_S64; {
            fprintf(f, "%lli", value.s64);
        }
        case KAI_WRITE_F32; {
            value.f64 = value.f32 -> f64;
        } #through;
        case KAI_WRITE_F64; {
            fprintf(f, "%f", value.f64);
        }
        case KAI_WRITE_FILL; {
            for i: 0..<format.min_count {
                fputc(format.fill_character, f);
            }
        }
        case; {
            fprintf(f, "[Writer] Case not defined for command %i\n", command);
        }
    }
}

_stdout_writer_write :: (user: *void, command: Write_Command, value: Value, format: Write_Format)
{
    user->void;
    _file_writer_write(stdout, command, value, format);
}

writer_stdout :: () -> Writer
{
    _setup_utf8_stdout();
    ret Writer.{
        write = _stdout_writer_write,
        user  = null,
    };
}

writer_file_open :: (path: cstring) -> Writer
{
    ret Writer.{
        write = _file_writer_write,
        user  = _stdc_file_open(path, "wb"),
    };
}

writer_file_close :: (writer: *Writer)
{
    f: *FILE = cast writer.user;
    if f != null
        fclose(f);
}
