#import "stdio.h";
#import "locale.h";

_term_debug_colors: [5] cstring = .{
    "\x1b[0;37m", // KAI_COLOR_PRIMARY     
    "\x1b[1;97m", // KAI_COLOR_SECONDARY   
    "\x1b[1;91m", // KAI_COLOR_IMPORTANT   
    "\x1b[1;94m", // KAI_COLOR_IMPORTANT_2 
    "\x1b[0;90m", // KAI_COLOR_DECORATION  
};

_file_writer_write_value :: (user: *void, type: u32, value: Value, format: Write_Format)
{
    if (user == null) ret;

    f: *FILE = cast user;
    if (type == FILL)
    {
        if (format.min_count == 0) ret;
        for i: 0..<format.min_count {
            fputc(format.fill_character, f);
        }
    }
    else if (type == KAI_F64)
    {
        fprintf(f, "%f", value.f64);
    }
    else if (type == KAI_S32)
    {
        fprintf(f, "%i", value.s32);
    }
    else if (type == KAI_U32)
    {
        fprintf(f, "%u", value.u32);
    }
    else if (type == KAI_S64)
    {
        fprintf(f, "%lli", value.s64);
    }
    else if (type == KAI_U64)
    {
        base: u8 = #char "u";

        if format.flags & KAI_WRITE_FLAGS_HEXIDECIMAL
            base = #char "X";

        if format.min_count != 0 {
            if format.fill_character != 0 {
                fmt: [7] char = "%.*ll.";
                fmt[1] = format.fill_character;
                fmt[5] = base;
                fprintf(f, fmt, format.min_count, value.u64);
            }
            else {
                fmt: [7] char = "%*ll.";
                fmt[4] = base;
                fprintf(f, fmt, format.min_count, value.u64);
            }
        }
        else {
            fmt: [5] char = "%ll.";
            fmt[3] = base;
            fprintf(f, fmt, value.u64);
        }
    }
    else
    {
        fprintf(f, "[Writer] -- Case not defined for type %i\n", type);
    }
}

_file_writer_write_string :: (user: *void, s: string)
{
    if (user == null) ret;
    f: *FILE = cast user;
    fwrite(s.data, 1, s.count, f);
}

_stdout_writer_write_value :: (user: *void, type: u32, value: Value, format: Write_Format)
{
    user->void;
    _file_writer_write_value(stdout, type, value, format);
}

_stdout_writer_write_string :: (user: *void, s: string)
{
    user->void;
    fwrite(s.data, 1, s.count, stdout);
}

_stdout_writer_set_color :: (user: *void, color: Write_Color)
{
    user->void;
    printf("%s", _term_debug_colors[color]);
}

writer_stdout :: () -> Writer
{
    _setup_utf8_stdout();
    ret Writer.{
        write_string   = _stdout_writer_write_string,
        write_value    = _stdout_writer_write_value,
        set_color      = _stdout_writer_set_color,
        user           = null,
    };
}

writer_file_open :: (path: cstring) -> Writer
{
    ret Writer.{
        write_string   = _file_writer_write_string,
        write_value    = _file_writer_write_value,
        set_color      = null,
        user           = _stdc_file_open(path, "wb"),
    };
}

writer_file_close :: (writer: *Writer)
{
    f: *FILE = cast writer.user;
    if f != null fclose(f);
}
