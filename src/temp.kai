
_type_check_literal :: (context: *Compiler_Context, l: *Expr_Literal, type: *Type_Info) -> bool
{
    l.this_type = type;
    if type.id == {
        case KAI_TYPE_ID_TYPE; kai__todo("TYPE");
        case KAI_TYPE_ID_VOID; kai__todo("VOID");
        case KAI_TYPE_ID_BOOLEAN; kai__todo("BOOLEAN");
        case KAI_TYPE_ID_INTEGER; kai__todo("INTEGER");
        case KAI_TYPE_ID_FLOAT; kai__todo("FLOAT");
        case KAI_TYPE_ID_POINTER; kai__todo("POINTER");
        case KAI_TYPE_ID_PROCEDURE; kai__todo("PROCEDUfRE");
        case KAI_TYPE_ID_ARRAY; {
            t: *Type_Info_Array = cast type;
            // look at every item of 
            assert(t.cols == 0);
            assert(l.count == t.rows);
            current: *Expr =  l.head;
            while current != null {
                _type_check(context, current, *t.sub_type);
                current = current.next;
            }
            ret false;
        }
        case KAI_TYPE_ID_STRUCT; kai__todo("STRUCT");
        case KAI_TYPE_ID_STRING; kai__todo("STRING");
        case; {
            kai__todo("what are types????");
        }
    }
    ret true;
}

_compile_node_type :: (context: *Compiler_Context, node: *Node) -> bool
{
    import: *Import;
    if node.flags & KAI_NODE_IMPORT {
        import = _find_host_import(context, node.location.string);
        if import == null
            ret _error_host_import_not_found(context, node.location);

        if node.type_expr == null {
            if import.type.count == 0
                ret _error_fatal(context, STRING("host import must be typed"));

            node.type_expr = _type_expression_from_string(context, import.type);
            if node.type_expr == null ret true;
        }

        node.value = import.value;
    }

    if node.type_expr != null {
        type: *Type_Info;
        value: Value;

        if _value_of_expression(context, node.type_expr, *value, *type)
            ret true;
        
        if type == null
            ret true;

        if type.id != KAI_TYPE_ID_TYPE
            ret _error_fatal(context, STRING("type is not type"));

        // check type against import
        if node.flags & KAI_NODE_IMPORT && import.type.count != 0
        {
            import_type_expr: *Expr = _type_expression_from_string(context, import.type);
            if import_type_expr == null ret true;
            
            import_type_type: *Type_Info;
            import_type_value: Value;

            if _value_of_expression(context, import_type_expr, *import_type_value, *import_type_type)
                ret true;

            if import_type_type == null
                ret true;

            if import_type_type.id != KAI_TYPE_ID_TYPE
                ret _error_fatal(context, STRING("import expr type is not type"));

            if value.type != import_type_value.type
                ret _error_fatal(context, STRING("import type does not match declaration"));
        }
        
        node.type = value.type;
        node.flags |= KAI_NODE_TYPE_EVALUATED;
        ret false;
    }

    type: Type;
    if _type_of_expression(context, node.value_expr, *type)
        ret true;

    node.type = type;
    node.flags |= KAI_NODE_TYPE_EVALUATED;
    ret false;
}
