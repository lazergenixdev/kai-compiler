#import "stdlib.h";
//#import "_memory_platform_allocate.h"; @insert

Memory_Error :: enum u32 {
    OUT_OF_MEMORY  = 1; // see memory_create implementation
    MEMORY_LEAK    = 2; // see memory_destroy implementation
}

Memory_Metadata :: struct {
    total_allocated: u64;
}

_memory_heap_allocate :: (user: *void, old_ptr: *void, new_size: u32, old_size: u32) -> *void
{
    ptr: *void = null;
    if new_size == 0 {
        free(old_ptr);
    } else {
        assert(old_ptr != null || old_size == 0);
        ptr = realloc(old_ptr, new_size);
        assert(ptr != null);
        if ptr != null
            _memory_zero(ptr->*u8 + old_size, new_size - old_size);
    }
    metadata: *Memory_Metadata = cast user;
    metadata.total_allocated += new_size;
    metadata.total_allocated -= old_size;
    ret ptr;
}

memory_create :: (out_allocator: *Allocator) -> Result
{
    assert(out_allocator != null);
    out_allocator.platform_allocate = _memory_platform_allocate;
    out_allocator.heap_allocate     = _memory_heap_allocate;
    out_allocator.page_size         = _page_size();
    out_allocator.user              = realloc(null, sizeof(Memory_Metadata));
    if !out_allocator.user {
        ret KAI_MEMORY_ERROR_OUT_OF_MEMORY;
    }
    metadata: *Memory_Metadata = cast out_allocator.user;
    metadata.total_allocated = 0;
    ret KAI_SUCCESS;
}

memory_destroy :: (allocator: *Allocator) -> Result
{
    assert(allocator != null);
    if (allocator.user == null)
        ret KAI_ERROR_FATAL;
    metadata: *Memory_Metadata = cast allocator.user;
    if metadata.total_allocated != 0
        ret KAI_MEMORY_ERROR_MEMORY_LEAK;
    free(allocator.user);
    [allocator] = Allocator.{0};
    ret KAI_SUCCESS;
}

memory_usage :: (allocator: *Allocator) -> u64
{
    metadata: *Memory_Metadata = cast allocator.user;
    ret metadata.total_allocated;
}