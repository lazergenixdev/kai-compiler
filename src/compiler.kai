
Compile_Flags :: enum u32 {
    COMPILE_NO_CODE_GEN      = 0x0001; // "type-check" only
    COMPILE_ALLOW_UNDEFINED  = 0x0002; // allow host imports that are not given a value
    COMPILE_DEBUG            = 0x8000; // enable debug printing
}

Compile_Options :: struct {
    interpreter_max_step_count : u32; // default(0) => 1000000
    interpreter_max_call_depth : u32; // default(0) => 1024
    flags                      : Compile_Flags;
}

Native_Procedure :: struct {
    name        : *u8;
    address     : *void;
    typestring  : string;
}

Import :: struct {
    name: string;
    type: string;
    value: Value;
}

/*
Resolve_Result :: enum u32 {
    FOUND_SOURCE :: 0;
    MISSING      :: 1;
}
P_Resolve_Import :: #proc (user: *void, name: string, out_source: *Source) -> Resolve_Result;
*/

Program_Create_Info :: struct {
    sources           : [] Source;
    imports           : [] Import;
    allocator         : Allocator;
    error             : *Error;
    options           : Compile_Options;
}

Variable :: struct {
    location: u32;
    type: Type;
}

Program :: struct {
    data            : [..] u8; // All exported program variables are stored here
    code: union {
        machine     : [] u8; // Machine code
        trees       : [] Syntax_Tree;
    };
    procedure_table : [string] u32;
    variable_table  : [string] Variable;
    type_table      : [string] Type;
    allocator       : Allocator;
}

Node_Flags :: enum u32 {
    NODE_TYPE            = 0x01;
    NODE_TYPE_EVALUATED  = 0x02;
    NODE_VALUE_EVALUATED = 0x04;
    NODE_EVALUATED       = 0x06;
    NODE_LOCAL           = 0x08;
    NODE_EXPORT          = 0x10;
    NODE_IMPORT          = 0x20;
    NODE_NOT_FOUND       = 0x80;
}

Node_Reference :: struct {
    flags: Node_Flags;
    index: u32;
}

// Nodes have two high level types: Procedure or anything else
// Nodes also live at Runtime or are Const
// Const nodes get baked into the program and do not live past compilation
//    while Runtime nodes can either be baked in (inlined) or hold a memory addess
// Only nodes that are explicitly marked with `#export` can be queried by the host program
Node :: struct {
    type:                   *Type_Info;  // evaluated type
    value:                   Value; // evaluated value
    location:                Location;
    expr:                   *Expr;
    type_expr:              *Expr;
    value_dependencies: [..] Node_Reference;
    type_dependencies:  [..] Node_Reference; // This can be arena??????
    flags:                   Node_Flags;
}

Local_Node :: struct {
    type:     *Type_Info;
    location:  Location;
}

Scope :: struct {
    identifiers: [string] Node_Reference;
    is_proc_scope: bool;
}

/* Sea of Nodes
IrTypeId :: enum u32 {
    BOT    = 0; // Bottom (ALL)
    TOP    = 1; // Top    (ANY)
    CTRL   = 2; // Ctrl flow bottom
    SIMPLE = 3; // End of the Simple Types
    NUMBER = 4; // All Numbers
    INT    = 4; // All Integers
    TUPLE  = 5; // Tuples; finite collections of unrelated Types, kept in parallel
}

IrTypeFlag :: enum u32 {
    CONST = 0x0001;
    TOP   = 0x0002;
}

IrValue :: union {
    number: Number;
    prim:   Value;
    tuple:  [..] IrType;
}

IrType :: struct {
    type:     IrTypeId;
    flags:    IrTypeFlag;
    value:    IrValue;
}

IrNode :: struct {
    id:       u32;
    inputs:   [..] *IrNode;
    outputs:  [..] *IrNode;
    type:     IrType;
}
*/

Compiler_Context :: struct {
    error:              *Error;
    allocator:           Allocator;
    program:            *Program;
    options:             Compile_Options;
    scopes:              [..] Scope;
    nodes:               [..] Node;
    local_nodes:         [..] Local_Node;
    imports:             [] Import;
    compilation_order:   [] u32;
    type_allocator:      Arena_Allocator;
    temp_allocator:      Arena_Allocator;
    current_source:      Source;
    current_node:        Node_Reference;
    number_type:        *Type_Info;
    type_type:          *Type_Info;
    bool_type:          *Type_Info;
    debug_writer:        Writer;
}

_create_syntax_trees :: (context: *Compiler_Context, sources: [] Source) -> bool
{
    allocator: *Allocator = *context.allocator;
    context.program.code.trees.data = _allocate(null, sources.count * sizeof(Syntax_Tree), 0) -> *Syntax_Tree;
    context.program.code.trees.count = sources.count;
    for i: 0..<sources.count {
        info: Syntax_Tree_Create_Info = Syntax_Tree_Create_Info.{
            source = sources[i],
            allocator = context.allocator,
            error = context.error,
        };
        if create_syntax_tree(*info, *array_last(*context.program.code.trees)) != KAI_SUCCESS
            ret true;
    }
    ret false;
}

_inside_procedure_scope :: (context: *Compiler_Context) -> bool
{
    for i: 0..<context.scopes.count {
        ri: u32 = context.scopes.count - 1 - i;
        scope: *Scope = *context.scopes.data[ri];
        if scope.is_proc_scope ret true;
    }
    ret false;
}

_error_redefinition :: (context: *Compiler_Context, location: Location, original: u32) -> bool
{
    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };

    buffer: Buffer = Buffer.{allocator = context.allocator};

    // First error message	
    {
        _buffer_append_string(*buffer, STRING("indentifier \""));
        _buffer_append_string(*buffer, location.string); // 24
        _buffer_append_string(*buffer, STRING("\" has already been declared"));
        range: Range = _buffer_end(*buffer);
        context.error.memory = _buffer_done(*buffer);
        context.error.message = _range_to_string(range, context.error.memory);
    }

    // Extra info
    {
        // Append to memory
        info_range: Range = _buffer_push(*buffer, sizeof(Error));
        _buffer_append_string(*buffer, STRING("see original definition of \""));
        _buffer_append_string(*buffer, location.string); // 24
        _buffer_append_string(*buffer, STRING("\""));
        message_range: Range = _buffer_end(*buffer);
        memory: Memory = _buffer_done(*buffer);

        existing: *Node = *context.nodes.data[original];

        // Put everything together
        info: *Error = (memory.data->*u8 + info_range.start) -> *Error;
        [info] = Error.{
            result = KAI_ERROR_INFO,
            location = existing.location,
            message = _range_to_string(message_range, memory),
            memory = memory,
        };
        context.error.next = info;
    }

    ret true;
}

_error_not_declared :: (context: *Compiler_Context, location: Location) -> bool
{
    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };
    buffer: Buffer = Buffer.{allocator = context.allocator};
    _buffer_append_string(*buffer, STRING("indentifier \""));
    _buffer_append_string(*buffer, location.string);
    _buffer_append_string(*buffer, STRING("\" not declared"));
    range: Range = _buffer_end(*buffer);
    context.error.memory = _buffer_done(*buffer);
    context.error.message = _range_to_string(range, context.error.memory);
    ret true;
}

_create_nodes :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    allocator: *Allocator = *context.allocator;
    allocator->void;

    if expr.id == {
    case KAI_EXPR_PROCEDURE; {
        /*
        Kai_Expr_Procedure* node = base;

        Kai_u32 new_scope_index = Context->scopes.count;
        kai__array_append(&Context->scopes, (Kai__DG_Scope) {
            .parent = Scope_Index,
            .is_proc_scope = KAI_TRUE,
        });
        //kai__hash_table_create(&Context->scopes.elements[new_scope_index].identifiers);

        node->_scope = new_scope_index;
        if (node->body) {
            return kai__dg_create_nodes_from_statement(Context, node->body, new_scope_index, KAI_TRUE, KAI_TRUE);
        }
        else {
            kai__todo("Native Functions not implemented!");
        }
        */
    }
    case KAI_STMT_IF; {
        /*
        Kai_Stmt_If* node = base;

        result = kai__dg_create_nodes_from_statement(Context, node->then_body, Scope_Index, In_Procedure, KAI_FALSE);
        if (result != KAI_SUCCESS)
            return result;

        if (node->else_body) {
            result = kai__dg_create_nodes_from_statement(Context, node->else_body, Scope_Index, In_Procedure, KAI_FALSE);
            if (result != KAI_SUCCESS)
                return result;
        }
        */
    }
    case KAI_STMT_FOR; {
        /*
        Kai_Stmt_For* node = base;
        return kai__dg_create_nodes_from_statement(Context, node->body, Scope_Index, In_Procedure, KAI_FALSE);
        */
    }
    case KAI_STMT_DECLARATION; {
        d: *Stmt_Declaration = cast expr;

        // Skip non-constants
        if (!(d.flags & KAI_FLAG_DECL_CONST) && _inside_procedure_scope(context))
            ret false;

        location: Location = Location.{
            source = context.current_source,
            string = d.name,
            line = d.line_number,
        };

        scope: *Scope = *array_last(*context.scopes);

        // Check redefinition
        {
            index: int = table_find(*scope.identifiers, d.name);
            if index != -1 {
                reference: Node_Reference = scope.identifiers.values[index];
                context.error.result = KAI_ERROR_FATAL;
                ret _error_redefinition(context, location, reference.index);
            }
        }
        // Push node onto scope
        {
            reference: Node_Reference = Node_Reference.{index = context.nodes.count};
            node: Node = Node.{location = location, expr = d.expr, type_expr = d.type};

            if d.flags & KAI_FLAG_DECL_HOST_IMPORT
                node.flags |= KAI_NODE_IMPORT;

            if d.flags & KAI_FLAG_DECL_EXPORT
                node.flags |= KAI_NODE_EXPORT;

            array_push(*node.value_dependencies, Node_Reference.{flags = KAI_NODE_TYPE, index = reference.index});
            array_push(*context.nodes, node);
            table_set(*scope.identifiers, d.name, reference);
        }
        ret false;
    }
    case KAI_STMT_COMPOUND; {
        c: *Stmt_Compound = cast expr;
        array_push(*context.scopes, Scope.{0});
        current: *Stmt = c.head;
        while current {
            if _create_nodes(context, current)
                ret true;
            current = current.next;
        }
        array_pop(*context.scopes);
        ret false;
    }
    }
    ret false;
}

_lookup_node :: (context: *Compiler_Context, name: string) -> Node_Reference
{
    for i: 0..<context.scopes.count {
        ri: u32 = context.scopes.count - 1 - i;
        scope: *Scope = *context.scopes.data[ri];
        k: int = table_find(*scope.identifiers, name);
        if k == -1 continue;
        ret scope.identifiers.values[k];
    }

    ret Node_Reference.{flags = KAI_NODE_NOT_FOUND};
}

add_dependency :: (context: *Compiler_Context, ref: Node_Reference)
{
    allocator: *Allocator = *context.allocator;
    deps: *[..] Node_Reference;
    node: *Node = *context.nodes.data[context.current_node.index];

    if context.current_node.flags & KAI_NODE_TYPE
        deps = *node.type_dependencies;
    else
        deps = *node.value_dependencies;

    for i: 0..<deps.count {
        other: Node_Reference = deps.data[i];
        if ref.index == other.index && ref.flags == other.flags
            ret;
    }
    array_push(deps, ref);
}

// Insert dependency for the value of an expression.
// In other words, the current_node will depend on the VALUE of `expr`
_insert_value_dependencies :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    allocator: *Allocator = *context.allocator;
    if expr == null { kai__todo("null expression\n"); }

    if expr.id == {
    case KAI_EXPR_IDENTIFIER; {
        ref: Node_Reference = _lookup_node(context, expr.source_code);

        if ref.flags & KAI_NODE_NOT_FOUND {
            node: *Node = *context.nodes.data[context.current_node.index];
            location: Location = Location.{source = node.location.source, string = expr.source_code, line = expr.line_number};
            ret _error_not_declared(context, location);
        }

        if ref.flags & KAI_NODE_LOCAL break;
        
        add_dependency(context, ref);
    }
    case KAI_EXPR_UNARY; {
        u: *Expr_Unary = cast expr;
        ret _insert_value_dependencies(context, u.expr);
    }
    case KAI_EXPR_BINARY; {
        b: *Expr_Binary = cast expr;
        if _insert_value_dependencies(context, b.left) ret true;
        if _insert_value_dependencies(context, b.right) ret true;
    }
    case KAI_EXPR_PROCEDURE; {
        p: *Expr_Procedure = cast expr;

        // TODO: special case compound statement as body
        array_push(*context.scopes, Scope.{0});
        scope: *Scope = *array_last(*context.scopes);
        
        current: *Expr = p.in_out_expr;
        while current {
            // TODO: check repeat variables (redefinition)
            if current.name.count != 0 {
                ref: Node_Reference = Node_Reference.{flags = KAI_NODE_LOCAL};
                table_set(*scope.identifiers, current.name, ref);
            }
            current = current.next;
        }
        
        if p.body != null && _insert_value_dependencies(context, p.body)
            ret true;

        array_pop(*context.scopes);
    }
    case KAI_STMT_RETURN; {
        r: *Stmt_Return = cast expr;
        ret _insert_value_dependencies(context, r.expr);
    }
    case KAI_STMT_IF; {
        i: *Stmt_If = cast expr;
        if _insert_value_dependencies(context, i.expr) ret true;
        if i.then_body != null && _insert_value_dependencies(context, i.then_body) ret true;
        if i.else_body != null && _insert_value_dependencies(context, i.else_body) ret true;
    }
    case KAI_STMT_COMPOUND; {
        c: *Stmt_Compound = cast expr;
        current: *Expr = c.head;
        // TODO: add scopes
        while current != null {
            if _insert_value_dependencies(context, current)
                ret true;
            current = current.next;
        }
    }
/*
    case KAI_EXPR_PROCEDURE_CALL: {
        Kai_Expr_Procedure_Call* node = base;

        // Procedure calls in procedures are fine, we only need to know the type to generate the bytecode
        // TODO: possible bug for nested procedures
        if (In_Procedure) {
            result = kai__dg_insert_type_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->proc
            );
        }
        else {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->proc,
                In_Procedure
            );
        }
        if (result != KAI_SUCCESS)
            return result;

        Kai_Expr current = node->arg_head;
        while (current != NULL) {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                current,
                In_Procedure
            );
            if (result != KAI_SUCCESS)
                return result;
            current = current->next;
        }
    }
    break; case KAI_STMT_DECLARATION: {
        if (In_Procedure) {
            Kai_Stmt_Declaration* node = base;
            // Already has a dependency node
            if (node->flags & KAI_DECL_FLAG_CONST)
                return KAI_SUCCESS;
            Kai__DG_Scope* scope = Context->scopes.elements + Scope_Index;
            // Insert into local scope (if not already defined)
            Kai__DG_Node_Index* node_index = kai__hash_table_find(scope->identifiers, node->name);
            if (node_index != NULL && node_index->flags != KAI__DG_NODE_LOCAL_VARIABLE) {
                Kai__DG_Node* original = &Context->nodes.elements[node_index->value];
                return kai__error_redefinition(
                    Context->error,
                    allocator,
                    node->name,
                    node->line_number,
                    original->name,
                    original->line_number
                );
            }

            kai__hash_table_emplace(scope->identifiers,
                node->name,
                (Kai__DG_Node_Index) {
                    .flags = KAI__DG_NODE_LOCAL_VARIABLE,
                }
            );

            // Look into it's definition to find possible dependencies
            return kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->expr,
                KAI_TRUE
            );
        }
        else kai__todo("invalid declaration\n");
    }

    break; case KAI_STMT_ASSIGNMENT: {
        if (In_Procedure) {
            Kai_Stmt_Assignment* node = base;
            return kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->expr,
                KAI_TRUE
            );
        }
        else kai__todo("invalid assignment\n");
    }

    break; case KAI_STMT_FOR: {
        Kai_Stmt_For* node = base;
        return kai__dg_insert_value_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->body,
            In_Procedure
        );
    }
*/
    }

    ret false;
}

// Insert dependency for the type of an expression.
// In other words, the current_node will depend on the TYPE of `expr`
_insert_type_dependencies :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    if expr == null { kai__todo("null expression\n"); }

    if expr.id == {
    case KAI_EXPR_IDENTIFIER; {
        ref: Node_Reference = _lookup_node(context, expr.source_code);

        if ref.flags & KAI_NODE_NOT_FOUND {
            node: *Node = *context.nodes.data[context.current_node.index];
            location: Location = Location.{source = node.location.source, string = expr.source_code, line = expr.line_number};
            ret _error_not_declared(context, location);
        }

        if ref.flags & KAI_NODE_LOCAL break;
        
        ref.flags |= KAI_NODE_TYPE;
        add_dependency(context, ref);
    }

    // no dependency
    case KAI_EXPR_NUMBER;
    case KAI_EXPR_STRING;
    case KAI_EXPR_SPECIAL;

    case KAI_EXPR_UNARY; {
        u: *Expr_Unary = cast expr;
        ret _insert_type_dependencies(context, u.expr);
    }

    case KAI_EXPR_BINARY; {
        b: *Expr_Binary = cast expr;
        if _insert_type_dependencies(context, b.left) ret true;
        if b.op == #multi "->" {
            if _insert_value_dependencies(context, b.right) ret true;
        }
        else {
            if _insert_type_dependencies(context, b.right) ret true;
        }
    }
    
    case KAI_EXPR_PROCEDURE; {
        p: *Expr_Procedure = cast expr;
        current: *Expr = p.in_out_expr;
        while current != null {
            // Depend on the value of each type in procedure type
            if _insert_value_dependencies(context, current) ret true;
            current = current.next;
        }
    }

    case KAI_EXPR_STRUCT; {
        s: *Expr_Struct = cast expr;
        current: *Stmt = s.head;
        while current {
            // Depend on the value of each type in struct
            if _insert_value_dependencies(context, current) ret true;
            current = current.next;
        }
        ret false;
    }
    
    case KAI_EXPR_PROCEDURE_TYPE; {
        ret false; // always a type
    }
/*
    break; case KAI_EXPR_PROCEDURE_CALL: {
        Kai_Expr_Procedure_Call* node = base;

        result = kai__dg_insert_type_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->proc
        );
        if (result != KAI_SUCCESS)
            return result;

        Kai_Expr current = node->arg_head;
        while (current != NULL) {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                current,
                KAI_FALSE // TODO: possible bug here ??
            );
            if (result != KAI_SUCCESS)
                return result;
            current = current->next;
        }
    }

    break; case KAI_STMT_DECLARATION: {
        // What do we do here exactly?
        kai__todo("declaration\n");
    }

    break; case KAI_STMT_RETURN: {
        Kai_Stmt_Return* node = base;
        return kai__dg_insert_type_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->expr
        );
    }

    break; case KAI_STMT_COMPOUND: {
        kai__todo("compound\n");
    }
*/
    case; {
        kai__todo("need to implement id = %i", expr.id);
    }
    }
    
    ret false;
}

_generate_dependency_builtin_types :: (context: *Compiler_Context) -> bool
{
    //
    // TODO: There must be a better solution than this.
    // I think it would probably be better to have all
    // this pre-setup in static memory.
    //

    allocator: *Allocator = *context.allocator;
    scope: *Scope = *array_last(*context.scopes);
    ref: Node_Reference;
    ref.index = context.nodes.count;

    // #Type
    table_set(*scope.identifiers, STRING("void"),     Node_Reference.{index = context.nodes.count+1});
    table_set(*scope.identifiers, STRING("s8"),       Node_Reference.{index = context.nodes.count+2});
    table_set(*scope.identifiers, STRING("s16"),      Node_Reference.{index = context.nodes.count+3});
    table_set(*scope.identifiers, STRING("s32"),      Node_Reference.{index = context.nodes.count+4});
    table_set(*scope.identifiers, STRING("s64"),      Node_Reference.{index = context.nodes.count+5});
    table_set(*scope.identifiers, STRING("u8"),       Node_Reference.{index = context.nodes.count+6});
    table_set(*scope.identifiers, STRING("u16"),      Node_Reference.{index = context.nodes.count+7});
    table_set(*scope.identifiers, STRING("u32"),      Node_Reference.{index = context.nodes.count+8});
    table_set(*scope.identifiers, STRING("u64"),      Node_Reference.{index = context.nodes.count+9});
    table_set(*scope.identifiers, STRING("f32"),      Node_Reference.{index = context.nodes.count+10});
    table_set(*scope.identifiers, STRING("f64"),      Node_Reference.{index = context.nodes.count+11});
    table_set(*scope.identifiers, STRING("bool"),     Node_Reference.{index = context.nodes.count+12});
    // #Number
    table_set(*scope.identifiers, STRING("string"),   Node_Reference.{index = context.nodes.count+14});

    type_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    type_type.id = KAI_TYPE_ID_TYPE;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type_type}, flags = KAI_NODE_EVALUATED});
    context.type_type = type_type;
    
    void_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    void_type.id = KAI_TYPE_ID_VOID;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = void_type}, flags = KAI_NODE_EVALUATED});

    bits: u8 = 8;
    while bits <= 64 {
        type: *Type_Info_Integer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Integer));
        type.id = KAI_TYPE_ID_INTEGER;
        type.is_signed = true;
        type.bits = bits;
        array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type->Type}, flags = KAI_NODE_EVALUATED});
        bits *= 2;
    }

    u8_type: Type;
    uint_type: Type;
    bits = 8;
    while bits <= 64 {
        type: *Type_Info_Integer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Integer));
        type.id = KAI_TYPE_ID_INTEGER;
        type.is_signed = false;
        type.bits = bits;
        if bits == 8*sizeof(uint) {
            uint_type = type->Type;
        }
        if bits == 8 {
            u8_type = type->Type;
        }
        array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type->Type}, flags = KAI_NODE_EVALUATED});
        bits *= 2;
    }

    bits = 32;
    while bits <= 64 {
        type: *Type_Info_Float = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Float));
        type.id = KAI_TYPE_ID_FLOAT;
        type.bits = bits;
        array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type->Type}, flags = KAI_NODE_EVALUATED});
        bits *= 2;
    }

    bool_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    bool_type.id = KAI_TYPE_ID_BOOLEAN;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = bool_type->Type}, flags = KAI_NODE_EVALUATED});
    context.bool_type = bool_type;

    number_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    number_type.id = KAI_TYPE_ID_NUMBER;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = number_type}, flags = KAI_NODE_EVALUATED});
    context.number_type = number_type;

    pu8_type: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
    pu8_type.id = KAI_TYPE_ID_POINTER;
    pu8_type.sub_type = u8_type;
    string_type: *Type_Info_Struct = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Struct));
    string_type.id = KAI_TYPE_ID_STRING;
    string_type.size = sizeof(uint) + sizeof(*u8);
    string_type.fields.count = 2;
    string_type.fields.data = arena_allocate(*context.type_allocator, string_type.fields.count * sizeof(Struct_Field)) -> *Struct_Field;
    string_type.fields.data[0] = Struct_Field.{name = STRING("count"), offset = 0, type = uint_type};
    string_type.fields.data[1] = Struct_Field.{name = STRING("data"), offset = sizeof(uint), type = pu8_type->Type};
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = string_type->Type}, flags = KAI_NODE_EVALUATED});
    ret false;
}

_generate_dependency_graph :: (context: *Compiler_Context) -> bool
{
    allocator: *Allocator = *context.allocator;
    
    // Initialize Global Scope
    array_push(*context.scopes, Scope.{ is_proc_scope = false });

    if _generate_dependency_builtin_types(context)
        ret true;

    // Insert nodes from syntax tree
    for i: 0..<context.program.code.trees.count {
        tree: *Syntax_Tree = *context.program.code.trees.data[i];
        context.current_source = tree.source;

        current: *Stmt = tree.root.head;
        while current {
            if _create_nodes(context, current)
                ret true;
            current = current.next;
        }
    }

    // Insert dependencies for each node
    for i: 0..<context.nodes.count
    {
        node: *Node = *context.nodes.data[i];
        context.current_node.index = i;

        if node.flags & KAI_NODE_EVALUATED || node.flags & KAI_NODE_IMPORT
            continue;

        if node.expr != null {
            context.current_node.flags = 0;
            if _insert_value_dependencies(context, node.expr) ret true;
            context.current_node.flags = KAI_NODE_TYPE;
            if _insert_type_dependencies(context, node.expr) ret true;
        }

        context.current_node.flags = KAI_NODE_TYPE;
        if node.type_expr != null {
            if _insert_value_dependencies(context, node.type_expr)
                ret true;
        }
    }

    if context.options.flags & KAI_COMPILE_DEBUG
    for i: 14..<context.nodes.count {
        node: *Node = *context.nodes.data[i];
        printf("node (%i) %.*s", i, node.location.string.count->s32, node.location.string.data);
        for i: 0..<(32 - node.location.string.count) putchar(#char " ");
        printf(" V{ ");
        for j: 0..<node.value_dependencies.count {
            ref: Node_Reference = node.value_dependencies.data[j];
            id: u8 = #char "v";
            if ref.flags & KAI_NODE_TYPE id = #char "t";
            printf("%i%c", ref.index, id);
            if j+1 < node.value_dependencies.count
                printf(", ");
        }
        printf(" } T{ ");
        for j: 0..<node.type_dependencies.count {
            ref: Node_Reference = node.type_dependencies.data[j];
            id: u8 = #char "v";
            if ref.flags & KAI_NODE_TYPE id = #char "t";
            printf("%i%c", ref.index, id);
            if j+1 < node.type_dependencies.count
                printf(", ");
        }
        printf(" }\n");
    }

    ret false;
}

_DFS_Context :: struct {
    context: *Compiler_Context;
    post: *u32;
    prev: *u32;
    visited: *bool;
    next: u32;
}

_explore_dependencies :: (dfs: *_DFS_Context, ref: Node_Reference)
{
    index: u32 = (ref.index << 1) | (ref.flags & KAI_NODE_TYPE);
    dfs.visited[index] = true;

    node: *Node = *dfs.context.nodes.data[ref.index];

    deps: *[..] Node_Reference;
    if ref.flags & KAI_NODE_TYPE  deps = *node.type_dependencies;
    else                          deps = *node.value_dependencies;

    for d: 0..<deps.count {
        dep: Node_Reference = deps.data[d];
        d_index: u32 = (dep.index << 1) | (dep.flags & KAI_NODE_TYPE);

        if !dfs.visited[d_index] {
            dfs.prev[d_index] = index;
            _explore_dependencies(dfs, dep);
        }
    }

    dfs.post[index] = dfs.next;
    dfs.next += 1;
}

_generate_compilation_order :: (context: *Compiler_Context) -> bool
{
    // TODO: only one allocation necessary
    allocator: *Allocator = *context.allocator;
    dfs: _DFS_Context = _DFS_Context.{context = context, next = 0};
    dfs.post    = _allocate(null, context.nodes.count * 2 * sizeof(u32), 0) -> *u32;
    dfs.prev    = _allocate(null, context.nodes.count * 2 * sizeof(u32), 0) -> *u32;
    dfs.visited = _allocate(null, context.nodes.count * 2 * sizeof(bool), 0) -> *bool;
    _memory_fill(dfs.prev, 0xFF, context.nodes.count * 2 * sizeof(u32));

    // Perform DFS traversal
    for i: 0..<context.nodes.count {
        ref: Node_Reference = Node_Reference.{index = i};

        v: u32 = (ref.index << 1) | (ref.flags & KAI_NODE_TYPE);
        if !dfs.visited[v] _explore_dependencies(*dfs, ref);

        ref.flags = KAI_NODE_TYPE;
        t: u32 = (ref.index << 1) | (ref.flags & KAI_NODE_TYPE);
        if !dfs.visited[t] _explore_dependencies(*dfs, ref);
    }

    // Sort based on the post number to linearize the graph
    context.compilation_order.count = context.nodes.count * 2;
    context.compilation_order.data = _allocate(null, context.compilation_order.count * sizeof(u32), 0) -> *u32;

    for i: 0..<context.compilation_order.count {
        context.compilation_order.data[dfs.post[i]] = i;
    }

    if context.options.flags & KAI_COMPILE_DEBUG {
        for i: 28..<context.compilation_order.count {
            k: u32 = context.compilation_order.data[i];
            index: u32 = k >> 1;
            ch: u8 = #char "v";
            if k & 1 { ch = #char "t"; }
            printf("%i%c ", index, ch);
        }
        printf("\n");
    }

    ret false;
}

_error_fatal :: (context: *Compiler_Context, message: string) -> bool
{
    context.error.result = KAI_ERROR_FATAL;
    context.error.message = message;
    ret true;
}

_value_to_number :: (value: Value, type: *Type_Info, out_number: *Number) -> bool
{
    if type.id == {
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            num: Number = Number.{d = 1};
            if info.is_signed {
                num.is_neg = value.s64 < 0;
                if num.is_neg {
                    num.n = (-value.s64) -> u64;
                }
                else {
                    num.n = value.s64 -> u64;
                }
            }
            else {
                num.n = value.u64;
            }
            [out_number] = number_normalize(num);
            ret false;
        }

        case; {
            ret true;
        }
    }
}

_evaluate_binary_operation :: (op: u32, type: *Type_Info, a: Value, b: Value) -> Value
{
    if type.id == {
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            if info.is_signed {
                if info.bits == {
                    case 32; {
                        if op == {
                            case #char "+"; ret Value.{s32 = a.s32 + b.s32};
                            case #char "-"; ret Value.{s32 = a.s32 - b.s32};
                        }
                    }
                }
            }
            kai__todo("integer op = %i, is_signed = %i, bits = %i", op, info.is_signed, info.bits);
        }
        case KAI_TYPE_ID_FLOAT; {
            info: *Type_Info_Float = cast type;
            if info.bits == {
                case 32; {
                    if op == {
                        case #char "+"; ret Value.{f32 = a.f32 + b.f32};
                        case #char "-"; ret Value.{f32 = a.f32 - b.f32};
                    }
                }
            }
            kai__todo("float op = %i, bits = %i", op, info.bits);
        }
        case KAI_TYPE_ID_NUMBER; {
            if op == {
                case #char "+"; ret Value.{number = number_add(a.number, b.number)};
                case #char "-"; ret Value.{number = number_sub(a.number, b.number)};
                case #char "*"; ret Value.{number = number_mul(a.number, b.number)};
                case #char "/"; ret Value.{number = number_div(a.number, b.number)};
                // TODO: OK to treat shift as multiplying by power of 2?
                case #multi "<<"; ret Value.{number = number_mul(a.number, Number.{1, 1, b.number.n, 0})};
                case #multi ">>"; ret Value.{number = number_div(a.number, Number.{1, 1, b.number.n, 0})};
            }
            kai__todo("number op = %i", op);
        }
        case; {
            kai__todo("type.id = %i", type.id);
        }
    }
    ret Value.{0};
}

_type_check :: (context: *Compiler_Context, expr: *Expr, out_or_expected: **Type_Info) -> bool
{
    expected: *Type_Info = [out_or_expected];
    allocator: *Allocator = *context.allocator;
    if expr.id == {
        case KAI_EXPR_IDENTIFIER; {
            ref: Node_Reference = _lookup_node(context, expr.source_code);
            if ref.flags & KAI_NODE_NOT_FOUND {
                node: *Node = *context.nodes.data[context.current_node.index];
                location: Location = Location.{source = node.location.source, string = expr.source_code, line = expr.line_number};
                ret _error_not_declared(context, location);
            }
            // Local Node
            if ref.flags & KAI_NODE_LOCAL {
                local_node: *Local_Node = *context.local_nodes.data[ref.index];

                if local_node.type == null {
                    ret _error_fatal(context, STRING("local node type cannot be null"));
                }

                if expected == null {
                    [out_or_expected] = local_node.type;
                    expr.this_type = local_node.type;
                    ret false;
                }

                if local_node.type != expected
                    ret _error_fatal(context, STRING("oh no, not same type, bad"));

                expr.this_type = expected;
                ret false;
            }
            // Global Node
            node: *Node = *context.nodes.data[ref.index];

            if node.type == null {
                ret _error_fatal(context, STRING("node type cannot be null"));
            }

            if expected == null {
                expr.this_type = node.type;
                ret false;
            }

            if node.type != expected
                ret _error_fatal(context, STRING("oh no, types not same for node"));
            
            expr.this_type = expected;
        }
        case KAI_EXPR_PROCEDURE; {
            p: *Expr_Procedure = cast expr;
            assert(expected.id == KAI_TYPE_ID_PROCEDURE);
            pt: *Type_Info_Procedure = cast expected;
            array_push(*context.scopes, Scope.{0});
            scope: *Scope = *array_last(*context.scopes);
            local_node_count: u32 = context.local_nodes.count;
            current: *Expr = p.in_out_expr;
            for i: 0..<p.in_count {
                type: Type = pt.inputs.data[i];
                ref: Node_Reference = Node_Reference.{flags = KAI_NODE_LOCAL, index = context.local_nodes.count}; 
                array_push(*context.local_nodes, Local_Node.{
                    type = type,
                    location = Location.{
                        string = current.name,
                        line = current.line_number
                    },
                });
                table_set(*scope.identifiers, current.name, ref);
                current = current.next;
            }

            assert(pt.outputs.count <= 1);
            if _type_check(context, p.body, *pt.outputs.data[0])
                ret true;

            context.local_nodes.count = local_node_count;
            array_pop(*context.scopes);

            p.this_type = expected;
        }
        case KAI_EXPR_NUMBER; {
            n: *Expr_Number = cast expr;
            
            if expected == null {
                [out_or_expected] = context.number_type;
                n.this_type = context.number_type;
                ret false;
            }

            // see if number is representable in type that is expected
            if expected.id == {
                case KAI_TYPE_ID_INTEGER; {
                    if !number_is_integer(n.value)
                        ret _error_fatal(context, STRING("not integer"));
                }
                case KAI_TYPE_ID_FLOAT;
                case KAI_TYPE_ID_NUMBER;
                case; {
                    ret _error_fatal(context, STRING("cannot convert from number to unknown type"));
                }
            }

            n.this_type = expected;
        }
        case KAI_EXPR_BINARY; {
            b: *Expr_Binary = cast expr;

            if b.op == {
            case #multi "<<"; #through;
            case #multi ">>"; {
                lt: *Type_Info = expected;
                if _type_check(context, b.left, *lt)
                    ret true;
                rt: *Type_Info;
                if _type_check(context, b.right, *rt)
                    ret true;

                [out_or_expected] = lt;
                b.this_type = lt;

                if expected == null
                    ret false;

                if lt != expected
                    ret _error_fatal(context, STRING("shift not good type"));

                ret false;
            }
            // Comparisons
            case #multi "=="; #through;
            case #multi "!="; #through;
            case #multi "<"; #through;
            case #multi ">"; #through;
            case #multi "<="; #through;
            case #multi ">="; {
                if expected != null && expected.id != KAI_TYPE_ID_BOOLEAN
                    ret _error_fatal(context, STRING("must expect bool here"));

                lt: *Type_Info;
                rt: *Type_Info;

                if _type_check(context, b.left, *lt)
                    ret true;

                if lt.id == KAI_TYPE_ID_NUMBER {
                    if _type_check(context, b.right, *rt)
                        ret true;
                    lt = rt;
                    if _type_check(context, b.left, *lt)
                        ret true;
                }
                else {
                    rt = lt;
                    if _type_check(context, b.right, *rt)
                        ret true;
                }

                if lt != rt
                    ret _error_fatal(context, STRING("types no match, comparison"));

                [out_or_expected] = context.bool_type;
                b.this_type = context.bool_type;
                ret false;
            }
            case #multi "->"; {
                lt: *Type_Info = null;
                if _type_check(context, b.left, *lt)
                    ret true;

                rt: *Type_Info = context.type_type;
                if _type_check(context, b.right, *rt)
                    ret true;

                rv: Value;
                if _value_of_expression(context, b.right, *rv, *rt)
                    ret true;

                [out_or_expected] = rv.type;
                
                if expected == null {
                    b.this_type = rv.type;
                    ret false;
                }

                if rv.type != expected
                    ret _error_fatal(context, STRING("cast invalid"));

                b.this_type = expected;
                ret false;
            }
            case; {
                lt: *Type_Info = expected;
                rt: *Type_Info = expected;
                
                if expected != null {
                    if _type_check(context, b.right, *rt)
                        ret true;
                    if _type_check(context, b.left, *lt)
                        ret true;
                    if lt != rt
                        ret _error_fatal(context, STRING("types no match, binary"));
                }
                else {
                    if _type_check(context, b.left, *lt)
                        ret true;

                    if lt.id == KAI_TYPE_ID_NUMBER {
                        if _type_check(context, b.right, *rt)
                            ret true;
                        lt = rt;
                        if _type_check(context, b.left, *lt)
                            ret true;
                    }
                    else {
                        rt = lt;
                        if _type_check(context, b.right, *rt)
                            ret true;
                    }
                }

                b.this_type = lt;
            }
            }
        }
        case KAI_STMT_RETURN; {
            r: *Stmt_Return = cast expr;
            if _type_check(context, r.expr, out_or_expected)
                ret true;
        }
        case KAI_STMT_IF; {
            i: *Stmt_If = cast expr;
            expected: *Type_Info = context.bool_type;
            if _type_check(context, i.expr, *expected) ret true;
            if i.then_body != null && _type_check(context, i.then_body, out_or_expected) ret true;
            if i.else_body != null && _type_check(context, i.else_body, out_or_expected) ret true;
        }
        case KAI_STMT_COMPOUND; {
            c: *Stmt_Compound = cast expr;
            current: *Stmt = c.head;
            while current {
                if _type_check(context, current, out_or_expected)
                    ret true;
                current = current.next;
            }
        }
        case; {
            kai__todo("expr.id = %i", expr.id);
        }
    }
    ret false;
}

_value_of_expression :: (context: *Compiler_Context, expr: *Expr, out_value: *Value, out_type: *Type) -> bool
{
    assert(expr != null);

    if expr.id == {
        case KAI_EXPR_IDENTIFIER; {
            ref: Node_Reference = _lookup_node(context, expr.source_code);

            if ref.flags & KAI_NODE_NOT_FOUND
                ret _error_fatal(context, STRING("cant find node [todo]"));

            if ref.flags & KAI_NODE_LOCAL
                ret _error_fatal(context, STRING("expression cannot have local identifiers"));

            node: *Node = *context.nodes.data[ref.index];
            
            if !(node.flags & KAI_NODE_EVALUATED)
                ret _error_fatal(context, STRING("node not evaluated [todo]"));

            [out_value] = node.value;
            [out_type] = node.type;
            ret false;
        }

        case KAI_EXPR_NUMBER; {
            n: *Expr_Number = cast expr;
            [out_value] = Value.{number = n.value};
            [out_type] = context.number_type;
            ret false;
        }

        case KAI_EXPR_SPECIAL; {
            s: *Expr_Special = cast expr;
            if s.kind == {
                case KAI_SPECIAL_TYPE; {
                    out_value.type = context.type_type;
                    [out_type] = context.type_type;
                    ret false;
                }
            }
            kai__todo("special value not implemented");
        }

        case KAI_EXPR_UNARY; {
            u: *Expr_Unary = cast expr;

            et: *Type_Info;
            ev: Value;
            if _value_of_expression(context, u.expr, *ev, *et)
                ret true;

            if u.op == #char "*" {
                if et.id == KAI_TYPE_ID_TYPE {
                    pt: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
                    pt.id = KAI_TYPE_ID_POINTER;
                    pt.sub_type = ev.type;
                    out_value.type = pt -> Type;
                    [out_type] = context.type_type;
                    ret false;
                }
                else {
                    kai__todo("pointer to value");
                }
            }

            kai__todo("unary operator");
        }

        case KAI_EXPR_BINARY; {
            b: *Expr_Binary = cast expr;
            lt: *Type_Info;
            rt: *Type_Info;
            lv: Value;
            rv: Value;

            if _value_of_expression(context, b.left, *lv, *lt)
                ret true;

            if _value_of_expression(context, b.right, *rv, *rt)
                ret true;

            if lt != rt {
                // TODO: number => concrete type (except shift)
                if lt.id == KAI_TYPE_ID_NUMBER {
                    // rt => Number
                    if _value_to_number(rv, rt, *rv.number)
                        ret _error_fatal(context, STRING("cannot convert value to number"));

                    rt = context.number_type;
                }
                else if rt.id == KAI_TYPE_ID_NUMBER {
                    // lt => Number
                    if _value_to_number(lv, lt, *lv.number)
                        ret _error_fatal(context, STRING("cannot convert value to number"));

                    lt = context.number_type;
                }
                else _error_fatal(context, STRING("invalid binary expression [todo]"));
            }

            [out_value] = _evaluate_binary_operation(b.op, lt, lv, rv);
            [out_type] = lt;
            ret false;
        }

        case KAI_EXPR_PROCEDURE; {
            // TODO: compile procedure (recursively)
            current_node: *Node = *context.nodes.data[context.current_node.index];
            expected_type: *Type_Info = current_node.type;
            _type_check(context, expr, *expected_type);
            out_value.ptr = expr;
            ret false;
        }

        case KAI_EXPR_STRUCT; {
            s: *Expr_Struct = cast expr;
            st: *Type_Info_Struct = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Struct));
            st.id = KAI_TYPE_ID_STRUCT;
            // TODO: need to calculate real field count
            st.fields.count = s.field_count;
            st.fields.data = arena_allocate(*context.type_allocator, sizeof(Struct_Field) * st.fields.count) -> *Struct_Field;
            st.size = 0;

            current: *Expr = s.head;
            for i: 0..<s.field_count {
                assert(current.id == KAI_STMT_DECLARATION);
                d: *Stmt_Declaration = cast current;

                type: *Type_Info;
                value: Value;
                if _value_of_expression(context, d.type, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret true;

                st.fields.data[i] = Struct_Field.{
                    name = d.name,
                    offset = st.size,
                    type = value.type,
                };
                st.size += _type_size(value.type);
                current = current.next;
            }

            out_value.type = st -> Type;
            [out_type] = context.type_type;
            ret false;
        }
        
        case KAI_EXPR_PROCEDURE_TYPE; {
            p: *Expr_Procedure_Type = cast expr;
            
            pt: *Type_Info_Procedure = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Procedure));
            pt.id = KAI_TYPE_ID_PROCEDURE;
            pt.inputs.count = p.in_count;
            pt.inputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.inputs.count) -> *Type;
            pt.outputs.count = p.out_count;
            pt.outputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.outputs.count) -> *Type;

            current: *Expr = p.in_out_expr;
            for i: 0..<p.in_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expression(context, current, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret true;
                pt.inputs.data[i] = value.type;
                current = current.next;
            }
            for i: 0..<p.out_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expression(context, current, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret true;
                if value.type.id == KAI_TYPE_ID_VOID && p.out_count == 1 {
                    pt.outputs.count = 0;
                    break;
                }
                // TODO: allocate output types here
                pt.outputs.data[i] = value.type;
                current = current.next;
            }

            out_value.type = pt -> Type;
            [out_type] = context.type_type;
            ret false;
        }

        case; {
            kai__todo("%s (expr.id = %i)", __FUNCTION__, expr.id);
        }
    }

    ret true;
}

_type_of_expression :: (context: *Compiler_Context, expr: *Expr) -> Type
{
    // TODO: type cache
    assert(expr != null);

    if expr.id == {
        case KAI_EXPR_IDENTIFIER; {
            ref: Node_Reference = _lookup_node(context, expr.source_code);

            if ref.flags & KAI_NODE_NOT_FOUND {
                _error_fatal(context, STRING("cant find node [todo]"));
                ret null;
            }

            node: *Node = *context.nodes.data[ref.index];
            
            if !(node.flags & KAI_NODE_TYPE_EVALUATED) {
                _error_fatal(context, STRING("node type not evaluated [todo]"));
                ret null;
            }

            ret node.type;
        }

        case KAI_EXPR_NUMBER; {
            // TODO make better
            ref: Node_Reference = _lookup_node(context, STRING("s32"));
            if ref.flags & KAI_NODE_NOT_FOUND ret null;
            node: *Node = *context.nodes.data[ref.index];
            ret node.value.type;
        }

        case KAI_EXPR_STRING; {
            kai__todo("strings");
        }

        case KAI_EXPR_SPECIAL; {
            s: *Expr_Special = cast expr;
            if s.kind == {
                case KAI_SPECIAL_TYPE; {
                    ret context.type_type;
                }
            }
            kai__todo("special value not implemented");
        }

        case KAI_EXPR_UNARY; {
            u: *Expr_Unary = cast expr;
            et: *Type_Info = _type_of_expression(context, u.expr);

            if et == null

            if u.op == #char "*" {
                pt: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
                pt.id = KAI_TYPE_ID_POINTER;
                pt.sub_type = et;
                ret pt -> Type;
            }

            ret et;
        }

        case KAI_EXPR_BINARY; {
            b: *Expr_Binary = cast expr;
            if b.op == #multi "->" {
                rv: Value;
                rt: *Type_Info;

                if _value_of_expression(context, b.right, *rv, *rt)
                    ret null;

                if rt.id != KAI_TYPE_ID_TYPE {
                    kai__todo("must cast to a type");
                    ret null;
                }

                ret rv.type;
            }
            lt: *Type_Info = _type_of_expression(context, b.left);
            rt: *Type_Info = _type_of_expression(context, b.right);
            if lt != rt {
                if lt.id == KAI_TYPE_ID_NUMBER ret rt;
                if rt.id == KAI_TYPE_ID_NUMBER ret lt;
                kai__todo("binary expression with different types");
                ret null;
            }
            ret lt;
        }

        case KAI_EXPR_PROCEDURE; {
            p: *Expr_Procedure = cast expr;
            
            pt: *Type_Info_Procedure = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Procedure));
            pt.id = KAI_TYPE_ID_PROCEDURE;
            pt.inputs.count = p.in_count;
            pt.inputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.inputs.count) -> *Type;
            pt.outputs.count = p.out_count;
            pt.outputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.outputs.count) -> *Type;

            current: *Expr = p.in_out_expr;
            for i: 0..<p.in_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expression(context, current, *value, *type)
                    ret null;
                if type.id != KAI_TYPE_ID_TYPE ret null;
                pt.inputs.data[i] = value.type;
                current = current.next;
            }
            for i: 0..<p.out_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expression(context, current, *value, *type)
                    ret null;
                if type.id != KAI_TYPE_ID_TYPE ret null;
                pt.outputs.data[i] = value.type;
                current = current.next;
            }

            ret pt -> Type;
        }
        
        case KAI_EXPR_STRUCT; #through;
        case KAI_EXPR_PROCEDURE_TYPE; {
            ret context.type_type;
        }

        case; {
            kai__todo("%s (expr.id = %i)", __FUNCTION__, expr.id);
        }
    }

    ret null;
}

_compile_node_value :: (context: *Compiler_Context, node: *Node) -> bool
{
    type: *Type_Info = node.type;
    value: Value;

    if node.expr != null && _value_of_expression(context, node.expr, *value, *type)
        ret true;

    // Skip type-checking on procedures (TODO)
    if type == null && node.type.id == KAI_TYPE_ID_PROCEDURE {
        node.value = value;
        ret false;
    }
    
    if type != node.type {
        // Able to auto-cast Numbers => Integer | Float
        if type.id == KAI_TYPE_ID_NUMBER {
            if node.type.id == {
                case KAI_TYPE_ID_BOOLEAN; {
                    if value.number.n != 0 && (value.number.n != 1 || value.number.d != 1 || value.number.e != 0 || value.number.is_neg != 0)
                        ret _error_fatal(context, STRING("cannot convert number to bool"));
                    node.value.u8 = value.number.n -> u8;
                    ret false;
                }
                case KAI_TYPE_ID_INTEGER; {
                    // TODO: bounds check
                    node.value.u64 = number_to_u64(value.number);
                    ret false;
                }
                case KAI_TYPE_ID_FLOAT; {
                    // TODO: bounds check
                    type_info: *Type_Info_Float = cast node.type;
                    fv: f64 = number_to_f64(value.number);
                    if type_info.bits == 32
                        node.value.f32 = fv -> f32;
                    else
                        node.value.f64 = fv;
                    ret false;
                }
            }
        }

        ret _error_fatal(context, STRING("cannot convert [todo]"));
    }

    node.value = value;
    ret false;
}

_find_import :: (context: *Compiler_Context, name: string) -> *Import
{
    for i: 0..<context.imports.count {
        import: *Import = *context.imports.data[i];
        if string_equals(import.name, name)
            ret import;
    }
    ret null;
}

_expression_from_string :: (context: *Compiler_Context, s: string) -> *Expr
{
    parser: Parser;
    parser.tokenizer.source = s;
    parser.tokenizer.line_number = 1;
    parser.error = context.error;
    parser.arena = context.temp_allocator;

    tokenizer_next(*parser.tokenizer);
    type: *Expr = parse_type_expression(*parser);

    if type == null {
        _error_fatal(context, STRING("could not parse string"));
    }

    context.temp_allocator = parser.arena;
    ret type;
}

_compile_node_type :: (context: *Compiler_Context, node: *Node) -> bool
{
    import: *Import;
    if node.flags & KAI_NODE_IMPORT {
        import = _find_import(context, node.location.string);
        if import == null
            ret _error_fatal(context, STRING("cannot find import"));

        if node.type_expr == null {
            if import.type.count == 0
                ret _error_fatal(context, STRING("host import must be typed"));

            node.type_expr = _expression_from_string(context, import.type);
            if node.type_expr == null ret true;
        }

        node.value = import.value;
    }

    if node.type_expr != null {
        type: *Type_Info;
        value: Value;

        if _value_of_expression(context, node.type_expr, *value, *type)
            ret true;
        
        if type == null
            ret true;

        if type.id != KAI_TYPE_ID_TYPE
            ret _error_fatal(context, STRING("type is not type"));

        // check type against import
        if node.flags & KAI_NODE_IMPORT && import.type.count != 0
        {
            import_type_expr: *Expr = _expression_from_string(context, import.type);
            if import_type_expr == null ret true;
            
            import_type_type: *Type_Info;
            import_type_value: Value;

            if _value_of_expression(context, import_type_expr, *import_type_value, *import_type_type)
                ret true;

            if import_type_type == null
                ret true;

            if import_type_type.id != KAI_TYPE_ID_TYPE
                ret _error_fatal(context, STRING("import expr type is not type"));

            if value.type != import_type_value.type
                ret _error_fatal(context, STRING("import type does not match declaration"));
        }
        
        node.type = value.type;
        node.flags |= KAI_NODE_TYPE_EVALUATED;
        ret false;
    }

    type: Type = _type_of_expression(context, node.expr);
    if type == null
        ret true;

    node.type = type;
    node.flags |= KAI_NODE_TYPE_EVALUATED;
    ret false;
}

// ret #size(type)  (bytes)
_type_size :: (type: *Type_Info) -> u32
{
    if type.id == {
        case KAI_TYPE_ID_TYPE; {
            ret sizeof(Type);
        }
        case KAI_TYPE_ID_BOOLEAN; {
            ret 1;
        }
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            ret info.bits / 8;
        }
        case KAI_TYPE_ID_FLOAT; {
            info: *Type_Info_Float = cast type;
            ret info.bits / 8;
        }
        case KAI_TYPE_ID_POINTER; #through;
        case KAI_TYPE_ID_PROCEDURE; {
            ret sizeof(*void);
        }
        case KAI_TYPE_ID_STRING; #through;
        case KAI_TYPE_ID_STRUCT; {
            info: *Type_Info_Struct = cast type;
            ret info.size;
        }
    }

    kai__todo("type.id = %i", type.id);
    ret 0;
}

_copy_value :: (out: *u8, type: *Type_Info, value: Value)
{
    if type.id == {
        case KAI_TYPE_ID_TYPE; {
            [out -> *Type] = value.type;
        }
        case KAI_TYPE_ID_BOOLEAN; {
            [out -> *bool] = value.u8;
        }
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            if info.is_signed {
                if info.bits == {
                    case  8; [out -> *s8]  = value.s8;
                    case 16; [out -> *s16] = value.s16;
                    case 32; [out -> *s32] = value.s32;
                    case 64; [out -> *s64] = value.s64;
                }
            }
            else {
                if info.bits == {
                    case  8; [out -> *u8]  = value.u8;
                    case 16; [out -> *u16] = value.u16;
                    case 32; [out -> *u32] = value.u32;
                    case 64; [out -> *u64] = value.u64;
                }
            }
        }
        case KAI_TYPE_ID_FLOAT; {
            info: *Type_Info_Float = cast type;
            if info.bits == {
                case 32; [out -> *f32] = value.f32;
                case 64; [out -> *f64] = value.f64;
            }
        }
        case KAI_TYPE_ID_POINTER; #through;
        case KAI_TYPE_ID_PROCEDURE; {
            [out -> **void] = value.ptr;
        }
        case KAI_TYPE_ID_STRING; {
            [out -> *string] = value.string;   
        }
        case KAI_TYPE_ID_STRUCT; {
            info: *Type_Info_Struct = cast type;
            if info.size <= sizeof(Value)
                memcpy(out, value.inline_struct, info.size);
            else
                memcpy(out, value.ptr, info.size);
        }
        case; {
            kai__todo("type.id = %i", type.id);
        }
    }
}

_push_value :: (context: *Compiler_Context, type: *Type_Info, value: Value) -> u32
{
    allocator: *Allocator = *context.allocator;
    size: u32 = _max_u32(_type_size(type), 8);
    location: u32 = context.program.data.count;
    array_grow(*context.program.data, size);
    _copy_value(context.program.data.data + location, type, value);
    context.program.data.count += size;
    ret location;
}

_compile_all_nodes :: (context: *Compiler_Context) -> bool
{
    allocator: *Allocator = *context.allocator;
    for i: 0..<context.compilation_order.count
    {
        k: u32 = context.compilation_order.data[i];
        ref: Node_Reference = Node_Reference.{index = (k >> 1), flags = (k & 1)};
        node: *Node = *context.nodes.data[ref.index];

        if (node.flags & KAI_NODE_EVALUATED) == KAI_NODE_EVALUATED
            continue;

        context.current_source = node.location.source;
        context.current_node = ref;

        writer: *Writer = *context.debug_writer;

        if ref.flags & KAI_NODE_TYPE {
            if context.options.flags & KAI_COMPILE_DEBUG {
                printf("compiling typeof(%.*s)\n", node.location.string.count->s32, node.location.string.data);
            }
            if _compile_node_type(context, node)
                ret true;
            if context.options.flags & KAI_COMPILE_DEBUG {
                printf("=> ");
                write_type(*context.debug_writer, node.type);
                printf("\n");
            }
        }
        else {
            if context.options.flags & KAI_COMPILE_DEBUG {
                printf("compiling (%.*s)\n", node.location.string.count->s32, node.location.string.data);
            }
            if !(node.flags & KAI_NODE_IMPORT) {
                if _compile_node_value(context, node)
                    ret true;
            }
            if context.options.flags & KAI_COMPILE_DEBUG {
                printf("=> ");
                if node.type.id == {
                    case KAI_TYPE_ID_NUMBER; {
                        kai_write_number(writer, node.value.number);
                    }
                    case KAI_TYPE_ID_INTEGER; {
                        info: *Type_Info_Integer = cast node.type;
                        if info.is_signed _write_s64(node.value.s64);
                        else _write_u64(node.value.u64);
                    }
                    case KAI_TYPE_ID_FLOAT; {
                        //info: *Type_Info_Float = cast node.type;
                        _write_f64(node.value.f32 -> f64);
                    }
                    case KAI_TYPE_ID_PROCEDURE; {
                        _write("0x");
                        context.debug_writer.write_value(context.debug_writer.user, KAI_U64,
                            Value.{u64 = node.value.u64}, Write_Format.{flags = KAI_WRITE_FLAGS_HEXIDECIMAL});
                    }
                }
                printf("\n");
            }
            if node.flags & KAI_NODE_EXPORT {
                location: u32 = _push_value(context, node.type, node.value);
                table_set(*context.program.variable_table, node.location.string, Variable.{type = node.type, location = location});
            }
        }
    }
    ret false;
}

_generate_compiler_ir :: (context: *Compiler_Context) -> bool
{
    context->void;
    //context.error.result = KAI_ERROR_FATAL;
    ret false;
}

create_program :: (info: *Program_Create_Info, out_program: *Program) -> Result
{
    context: Compiler_Context = Compiler_Context.{
        error = info.error,
        allocator = info.allocator,
        program = out_program,
        options = info.options,
        imports = info.imports,
        debug_writer = writer_stdout(),
    };
    arena_create(*context.type_allocator, *info.allocator);
    arena_create(*context.temp_allocator, *info.allocator);

    if !(info.options.flags & KAI_COMPILE_NO_CODE_GEN) {
        context.error.message = STRING("Code generation not currently supported :(");
        context.error.result = KAI_ERROR_FATAL;
        ret KAI_ERROR_FATAL;
    }

    while context.error.result == KAI_SUCCESS {
        if _create_syntax_trees(*context, info.sources) break;
        if _generate_dependency_graph(*context) break;
        if _generate_compilation_order(*context) break;
        if _compile_all_nodes(*context) break;
        break;
    }

    ret context.error.result;
}

destroy_program :: (program: *Program)
{
    program->void;
}

find_variable :: (program: *Program, name: string, out_type: *Type) -> *void
{
    index: int = table_find(*program.variable_table, name);
    if index == -1 ret null;
    var: Variable = program.variable_table.values[index];
    if out_type != null {
        [out_type] = var.type;
    }
    ret program.data.data + var.location;
}
//@doc_description (
//"""
//This procedure returns a pointer to a variable in the script.
//Returning a pointer allows the host program to modify the variable at anytime
//after the script is compiled, and it is the host programmer's responsibility
//to handle things like race conditions.
//"""
//)
//@doc_warning ("If you wish to modify the variable, then make sure the variable is not declared as a constant in the script!")

find_procedure :: (program: *Program, name: string, type: string) -> *void
{
    type->void;
    t: *Type_Info;
    ptr: *void = find_variable(program, name, *t);
    if t == null || t.id != KAI_TYPE_ID_PROCEDURE ret null;
    ret ptr;

    //data: *u8 = cast malloc(name.count + type.count);
    //_memory_copy(data, name.data, name.count);
    //_memory_copy(data + name.count, type.data, type.count);
    //index: int = table_find(*program.procedure_table, string.{count = name.count + type.count, data = data});
    //free(data);
    //if index == -1
    //    ret null;
    //ret program.code.data + program.procedure_table.values[index];
}
