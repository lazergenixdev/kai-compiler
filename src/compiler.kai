
Compile_Flags :: enum u32 {
    COMPILE_NO_CODE_GEN      = 0x0001; // "type-check" only
    COMPILE_ALLOW_UNDEFINED  = 0x0002; // allow host imports that are not given a value
}

Compile_Options :: struct {
    interpreter_max_step_count : u32; // default(0) => 1000000
    interpreter_max_call_depth : u32; // default(0) => 1024
    flags                      : Compile_Flags;
}

Import :: struct {
    name: string;
    type: string;
    value: Value;
}

/*
Resolve_Result :: enum u32 {
    FOUND_SOURCE :: 0;
    MISSING      :: 1;
}
P_Resolve_Import :: #proc (user: *void, name: string, out_source: *Source) -> Resolve_Result;
*/

Program_Create_Info :: struct {
    sources           : [] Source;
    imports           : [] Import;
    allocator         : Allocator;
    error             : *Error;
    options           : Compile_Options;
    debug_writer      : *Writer;
}

Variable :: struct {
    location: u32;
    type: Type;
}

Program :: struct {
    data            : [..] u8; // All exported variables are stored here
    backend         : Backend;
    code            : [] u8;
    trees           : [] Syntax_Tree;
    procedure_table : [string] u32;
    variable_table  : [string] Variable;
    type_table      : [string] Type;
    allocator       : Allocator;
}

Node_Flags :: enum u32 {
    NODE_TYPE            = 0x01; // Node reference is referring to the node's type
    NODE_TYPE_EVALUATED  = 0x02;
    NODE_VALUE_EVALUATED = 0x04;
    NODE_EVALUATED       = 0x06; // Fully evaluated
    NODE_LOCAL           = 0x08;
    NODE_EXPORT          = 0x10;
    NODE_IMPORT          = 0x20;
    NODE_VISITED         = 0x40;
    NODE_NOT_FOUND       = 0x80;
}

Node_Reference :: struct {
    flags: Node_Flags;
    index: u32;
}

// Nodes have two high level types: Procedure or anything else
// Nodes also live at Runtime or are Const
// Const nodes get baked into the program and do not live past compilation
//    while Runtime nodes can either be baked in (inlined) or hold a memory addess
// Only nodes that are explicitly marked with `#export` can be queried by the host program
Node :: struct {
    type:        *Type_Info;  // evaluated type
    value:        Value;      // evaluated value
    location:     Location;
    value_expr:  *Expr;       // d : type : [value];
    type_expr:   *Expr;       // d : [type] : value;
    decl:        *Expr;
    flags:        Node_Flags;
}

Local_Node :: struct {
    type:       *Type_Info;
    location:    Location;
    stack_index: u32;
}

Scope :: struct {
    identifiers    : [string] Node_Reference;
    pending_nodes  : [..] Pending_Node;
    is_proc_scope  : bool;
}

Pending_Node :: struct {
    ref:           Node_Reference;
    dependencies:  [..] Node_Reference; // what needs to be compiled
}

_Builtin_Type_ID :: enum u8 {
    BUILTIN_TYPE             = 0;
    BUILTIN_VOID             = 1;
    BUILTIN_BOOL             = 2;
    BUILTIN_U8               = 3;
    BUILTIN_U16              = 4;
    BUILTIN_U32              = 5;
    BUILTIN_U64              = 6;
    BUILTIN_S8               = 7;
    BUILTIN_S16              = 8;
    BUILTIN_S32              = 9;
    BUILTIN_S64              = 10;
    BUILTIN_F32              = 11;
    BUILTIN_F64              = 12;
    BUILTIN_STRING           = 13;
    BUILTIN_NUMBER           = 14;
    BUILTIN_POINTER          = 15;
    BUILTIN_UNSIGNED_INTEGER = 16;
    BUILTIN_COUNT            = 17;
}

Compiler_Context :: struct {
    // Memory management
    allocator:              Allocator;
    error_arena:            Growing_Arena;
    type_allocator:         Arena_Allocator;
    temp_allocator:         Arena_Allocator;

    // Global context
    error:                 *Error; // TODO: set to the last error in chain?
    program:               *Program;
    options:                Compile_Options;
    imports:                [] Import;
    builtin_types:          [] Type; // TODO: need fixed size arrays
    nodes:                  [..] Node;
    local_nodes:            [..] Local_Node;
    trees:                  [] Syntax_Tree;
    type_cache:             [Type] u8;
    scopes:                 [..] Scope;

    // Info about what is currently being compiled
    current_node:           Node_Reference;
    current_source:         Source;
    current_dependencies:   [..] Node_Reference;

    // Code Generation
    assembler:              Assembler;
    stack_index:            u32;
    last_variable_index:    u32;

    // TODO: use builtin types
    number_type:           *Type_Info;
    string_type:           *Type_Info;
    type_type:             *Type_Info;
    bool_type:             *Type_Info;

    debug_writer:          *Writer;
}

_create_syntax_trees :: (context: *Compiler_Context, sources: [] Source) -> bool
{
    allocator: *Allocator = *context.allocator;
    context.trees.data = _allocate(null, sources.count * sizeof(Syntax_Tree), 0) -> *Syntax_Tree;
    context.trees.count = sources.count;
    for i: 0..<sources.count {
        info: Syntax_Tree_Create_Info = Syntax_Tree_Create_Info.{
            source = sources[i],
            allocator = context.allocator,
            error = context.error,
        };
        if create_syntax_tree(*info, *array_last(*context.trees)) != KAI_SUCCESS
            ret true;
    }
    ret false;
}

_write_expression_name :: (writer: *Writer, expr: *Expr)
{
    assert(expr != null);
    if expr.id == {
        case KAI_EXPR_IDENTIFIER; {
            _write("\"");
            _write_string(expr.source_code);
            _write("\"");
        }
        case KAI_EXPR_STRING;         _write("string");
        case KAI_EXPR_NUMBER;         _write("number");
        case KAI_EXPR_LITERAL;        _write("literal");
        case KAI_EXPR_UNARY;          _write("expression");
        case KAI_EXPR_BINARY;         _write("expression");
        case KAI_EXPR_PROCEDURE_TYPE; _write("procedure type");
        case KAI_EXPR_PROCEDURE_CALL; _write("procedure call");
        case KAI_EXPR_PROCEDURE;      _write("procedure");
        case KAI_EXPR_CODE;           _write("code");
        case KAI_EXPR_IMPORT;         _write("import");
        case KAI_EXPR_STRUCT;         _write("struct");
        case KAI_EXPR_ENUM;           _write("enum");
        case KAI_EXPR_ARRAY;          _write("array");
        case KAI_EXPR_SPECIAL; {
            _write_string(expr.source_code);
        }
        case;                         _write("UNKNOWN");
    }
}

_inside_procedure_scope :: (context: *Compiler_Context) -> bool
{
    for i: 0..<context.scopes.count {
        ri: u32 = context.scopes.count - 1 - i;
        scope: *Scope = *context.scopes.data[ri];
        if scope.is_proc_scope ret true;
    }
    ret false;
}

_error_fatal :: (context: *Compiler_Context, message: string) -> bool
{
    context.error.result = KAI_ERROR_FATAL;
    context.error.message = message;
    context.error.location.source = context.current_source;
    kai__debug_print_stacktrace();
    ret true;
}

_error_redefinition :: (context: *Compiler_Context, location: Location, original: u32) -> bool
{
    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };

    buffer: Buffer = Buffer.{allocator = context.allocator};

    // First error message	
    {
        _buffer_append_string(*buffer, STRING("identifier \""));
        _buffer_append_string(*buffer, location.string); // 24
        _buffer_append_string(*buffer, STRING("\" has already been declared"));
        range: Range = _buffer_end(*buffer);
        context.error.memory = _buffer_done(*buffer);
        context.error.message = _range_to_string(range, context.error.memory);
    }

    // Extra info
    {
        // Append to memory
        info_range: Range = _buffer_push(*buffer, sizeof(Error));
        _buffer_append_string(*buffer, STRING("see original definition of \""));
        _buffer_append_string(*buffer, location.string); // 24
        _buffer_append_string(*buffer, STRING("\""));
        message_range: Range = _buffer_end(*buffer);
        memory: Memory = _buffer_done(*buffer);

        existing: *Node = *context.nodes.data[original];

        // Put everything together
        info: *Error = (memory.data->*u8 + info_range.start) -> *Error;
        [info] = Error.{
            result = KAI_ERROR_INFO,
            location = existing.location,
            message = _range_to_string(message_range, memory),
            memory = memory,
        };
        context.error.next = info;
    }

    ret true;
}

_error_not_declared :: (context: *Compiler_Context, location: Location) -> bool
{
    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };
    error_writer: Writer = writer_from_arena(*context.error_arena);
    writer: *Writer = *error_writer;

    message_offset: u32 = context.error_arena.buffer.count;
    _write("identifier \"");
    _write_string(location.string);
    _write("\" not declared");
    message_count: u32 = context.error_arena.buffer.count - message_offset;

    context.error.message = string_from_data(context.error_arena.buffer.data + message_offset, message_count);
    //kai__debug_print_stacktrace();
    ret true;
}

_error_circular_dependency :: (context: *Compiler_Context) -> bool
{
    // NOTE: `current_node` is expected to be the root,
    // and `current_dependencies` is the dependency chain that fails.

    node: *Node = *context.nodes.data[context.current_node.index];

    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = node.location,
    };
    allocator: *Allocator = *context.allocator;
    array_reserve(*context.error_arena.buffer, 2*1024); // TODO: fix
    error_writer: Writer = writer_from_arena(*context.error_arena);
    writer: *Writer = *error_writer;

    message_offset: u32 = context.error_arena.buffer.count;
    _write("detected circular dependency on \"");
    _write_string(node.location.string);
    _write("\"");
    message_count: u32 = context.error_arena.buffer.count - message_offset;
    context.error.message = string_from_data(context.error_arena.buffer.data + message_offset, message_count);

    current_error: *Error = context.error;
    prev_ref: Node_Reference = context.current_node;
    prev_node: *Node = node;
    error: Error = Error.{0}; // TODO: need way to just allocate space?
    temp: *Writer = context.debug_writer;
    context.debug_writer = writer;
    for i: 0..<context.current_dependencies.count {
        ref: Node_Reference = context.current_dependencies.data[i];
        node: *Node = *context.nodes.data[ref.index];
        next: *Error = cast growing_arena_push(*context.error_arena, *error, sizeof(Error));

        message_offset: u32 = context.error_arena.buffer.count;
        _write_node(writer, prev_node, prev_ref.flags);
        _write(" depends on ");
        _write_node(writer, node, ref.flags);
        message_count: u32 = context.error_arena.buffer.count - message_offset;
        
        [next] = Error.{
            result = KAI_ERROR_INFO,
            location = node.location,
            message = string_from_data(context.error_arena.buffer.data + message_offset, message_count),
        };
        current_error.next = next;
        current_error = next;
        prev_ref = ref;
        prev_node = node;
    }
    context.debug_writer = temp;
    ret true;
}

_error_type_check :: (context: *Compiler_Context, expr: *Expr, expected: Type, got: Type) -> bool
{
    location: Location = Location.{
        source = context.current_source,
        string = expr.source_code,
        line = expr.line_number,
    };

    [context.error] = Error.{
        result = KAI_ERROR_TYPE,
        location = location,
    };
    error_writer: Writer = writer_from_arena(*context.error_arena);
    writer: *Writer = *error_writer;

    message_offset: u32 = context.error_arena.buffer.count;
    _write("expected ");
    _write_expression_name(writer, expr);
    _write(" of type ");
    write_type(writer, got);
    _write(" to be of type ");
    write_type(writer, expected);
    message_count: u32 = context.error_arena.buffer.count - message_offset;

    context.error.message = string_from_data(context.error_arena.buffer.data + message_offset, message_count);
    //kai__debug_print_stacktrace();
    ret true;
}

_error_no_member :: (context: *Compiler_Context, type: Type, identifier: *Expr) -> bool
{
    location: Location = Location.{
        source = context.current_source,
        string = identifier.source_code,
        line = identifier.line_number,
    };

    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };
    error_writer: Writer = writer_from_arena(*context.error_arena);
    writer: *Writer = *error_writer;

    message_offset: u32 = context.error_arena.buffer.count;
    _write("type ");
    write_type(writer, type);
    _write(" has no member named \"");
    _write_string(identifier.source_code);
    _write("\"");
    message_count: u32 = context.error_arena.buffer.count - message_offset;

    context.error.message = string_from_data(context.error_arena.buffer.data + message_offset, message_count);
    //kai__debug_print_stacktrace();
    ret true;
}

_error_host_import_not_found :: (context: *Compiler_Context, location: Location) -> bool
{
    [context.error] = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };
    buffer: Buffer = Buffer.{allocator = context.allocator};
    _buffer_append_string(*buffer, STRING("could not find host import \""));
    _buffer_append_string(*buffer, location.string);
    _buffer_append_string(*buffer, STRING("\""));
    range: Range = _buffer_end(*buffer);
    context.error.memory = _buffer_done(*buffer);
    context.error.message = _range_to_string(range, context.error.memory);
    ret true;
}

_write_node :: (writer: *Writer, node: *Node, flags: Node_Flags)
{
    if flags & KAI_NODE_TYPE _write("type of \"");
    else _write("value of \"");
    _write_string(node.location.string);
    _write("\"");
}

_create_nodes :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    //
    // NOTE: Create node for each declaration in this scope.
    // Nodes recurse one step into procedures to make call simplier.
    //

    allocator: *Allocator = *context.allocator;

    if expr.id == {
    case KAI_EXPR_IMPORT; {
        writer: *Writer = context.debug_writer;
        if writer != null {
            _write("import: \"");
            _write_string(expr.name);
            _write("\"\n");
        }
        
        kai__todo("what's an import again?");
    }
    case KAI_STMT_DECLARATION; {
        d: *Stmt_Declaration = cast expr;

        // Skip non-constants
        if (!(d.flags & KAI_FLAG_DECL_CONST) && _inside_procedure_scope(context))
            ret false;

        location: Location = Location.{
            source = context.current_source,
            string = d.name,
            line = d.line_number,
        };

        scope: *Scope = *array_last(*context.scopes);

        // Check redefinition
        {
            index: int = table_find(*scope.identifiers, d.name);
            if index != -1 {
                reference: Node_Reference = scope.identifiers.values[index];
                context.error.result = KAI_ERROR_FATAL;
                ret _error_redefinition(context, location, reference.index);
            }
        }
        // Push node onto scope
        {
            reference: Node_Reference = Node_Reference.{index = context.nodes.count};
            node: Node = Node.{location = location, value_expr = d.value, type_expr = d.type, decl = expr};

            if d.flags & KAI_FLAG_DECL_HOST_IMPORT
            {
                node.flags |= KAI_NODE_IMPORT;
                import: *Import = _find_host_import(context, node.location.string);
                if import == null
                    ret _error_host_import_not_found(context, node.location);

                if node.type_expr == null {
                    if import.type.count == 0
                        ret _error_fatal(context, STRING("host import must be typed"));

                    node.type_expr = _type_expression_from_string(context, import.type);
                    if node.type_expr == null ret true;
                }
                node.value = import.value;
                node.flags |= KAI_NODE_VALUE_EVALUATED;
            }

            if d.flags & KAI_FLAG_DECL_EXPORT
                node.flags |= KAI_NODE_EXPORT;

            writer: *Writer = context.debug_writer;
            if writer != null {
                _write("inserting node for \"");
                _write_string(d.name);
                _write("\"\n");
            }

            table_set(*scope.identifiers, d.name, reference);

            type_reference: Node_Reference = Node_Reference.{flags = KAI_NODE_TYPE, index = reference.index};
            array_push(*scope.pending_nodes, Pending_Node.{ref = type_reference});

            if !(d.flags & KAI_FLAG_DECL_HOST_IMPORT) {
                value_dependencies: [..] Node_Reference;
                array_push(*value_dependencies, type_reference);
                array_push(*scope.pending_nodes, Pending_Node.{ref = reference, dependencies = value_dependencies});
            }
            array_push(*context.nodes, node);
        }
    }
    case KAI_STMT_COMPOUND; {
        c: *Stmt_Compound = cast expr;
        current: *Stmt = c.head;
        while current {
            if _create_nodes(context, current)
                ret true;
            current = current.next;
        }
    }
    }
    ret false;
}

_generate_nodes :: (context: *Compiler_Context) -> bool
{
    allocator: *Allocator = *context.allocator;
    
    // Initialize Global Scope
    array_push(*context.scopes, Scope.{ is_proc_scope = false });

    if _generate_builtin_types(context)
        ret true;

    // Insert nodes from syntax tree
    for i: 0..<context.trees.count {
        tree: *Syntax_Tree = *context.trees.data[i];
        context.current_source = tree.source;
        current: *Stmt = tree.root.head;
        while current {
            if _create_nodes(context, current)
                ret true;
            current = current.next;
        }
    }
    ret false;
}

_lookup_node :: (context: *Compiler_Context, name: string) -> Node_Reference
{
    for i: 0..<context.scopes.count {
        ri: u32 = context.scopes.count - 1 - i;
        scope: *Scope = *context.scopes.data[ri];
        k: int = table_find(*scope.identifiers, name);
        if k == -1 continue;
        ret scope.identifiers.values[k];
    }
    ret Node_Reference.{flags = KAI_NODE_NOT_FOUND};
}

_debug_show_type :: (context: *Compiler_Context, type: Type)
{
    writer: *Writer = context.debug_writer;
    if writer != null {
        //_write("Hash ");
        //writer.write(writer.user, KAI_WRITE_U64, Value.{u64 = hash_type(type)},
        //    Write_Format.{flags = KAI_WRITE_FLAGS_BASE_16, fill_character = #char "0", min_count = 16});
        //_write(" ");
        _set_color(KAI_WRITE_COLOR_TYPE);
        write_type(writer, type);
        _set_color(KAI_WRITE_COLOR_DEFAULT);
        _write(" ");
        writer.write(writer.user, KAI_WRITE_U64, Value.{u64 = type->u64},
            Write_Format.{flags = KAI_WRITE_FLAGS_BASE_16, fill_character = #char "0", min_count = 16});
        _write("\n");
    }
}

_generate_builtin_types :: (context: *Compiler_Context) -> bool
{
    //
    // TODO: There must be a better solution than this.
    // I think it would probably be better to have all
    // this pre-setup in static memory.
    //

    allocator: *Allocator = *context.allocator;
    scope: *Scope = *array_last(*context.scopes);
    ref: Node_Reference;
    ref.index = context.nodes.count;

    context.builtin_types.data = _allocate(null, KAI_BUILTIN_COUNT * sizeof(Type), 0);
    context.builtin_types.count = KAI_BUILTIN_COUNT;

    // #Type
    table_set(*scope.identifiers, STRING("void"),     Node_Reference.{index = context.nodes.count+1});
    table_set(*scope.identifiers, STRING("s8"),       Node_Reference.{index = context.nodes.count+2});
    table_set(*scope.identifiers, STRING("s16"),      Node_Reference.{index = context.nodes.count+3});
    table_set(*scope.identifiers, STRING("s32"),      Node_Reference.{index = context.nodes.count+4});
    table_set(*scope.identifiers, STRING("s64"),      Node_Reference.{index = context.nodes.count+5});
    table_set(*scope.identifiers, STRING("u8"),       Node_Reference.{index = context.nodes.count+6});
    table_set(*scope.identifiers, STRING("u16"),      Node_Reference.{index = context.nodes.count+7});
    table_set(*scope.identifiers, STRING("u32"),      Node_Reference.{index = context.nodes.count+8});
    table_set(*scope.identifiers, STRING("u64"),      Node_Reference.{index = context.nodes.count+9});
    table_set(*scope.identifiers, STRING("f32"),      Node_Reference.{index = context.nodes.count+10});
    table_set(*scope.identifiers, STRING("f64"),      Node_Reference.{index = context.nodes.count+11});
    table_set(*scope.identifiers, STRING("bool"),     Node_Reference.{index = context.nodes.count+12});
    // #Number
    table_set(*scope.identifiers, STRING("string"),   Node_Reference.{index = context.nodes.count+14});

    type_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    type_type.id = KAI_TYPE_ID_TYPE;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type_type}, flags = KAI_NODE_EVALUATED});
    context.type_type = type_type;
    context.builtin_types.data[KAI_BUILTIN_TYPE] = type_type;
    _debug_show_type(context, type_type);
    
    void_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    void_type.id = KAI_TYPE_ID_VOID;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = void_type}, flags = KAI_NODE_EVALUATED});
    context.builtin_types.data[KAI_BUILTIN_VOID] = void_type;
    _debug_show_type(context, void_type);

    bits: u8 = 8;
    i: u32 = 0;
    while bits <= 64 {
        type: *Type_Info_Integer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Integer));
        type.id = KAI_TYPE_ID_INTEGER;
        type.is_signed = true;
        type.bits = bits;
        array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type->Type}, flags = KAI_NODE_EVALUATED});
        context.builtin_types.data[KAI_BUILTIN_U8 + i] = type->Type;
        bits *= 2;
        i += 1;
    }

    u8_type: Type;
    uint_type: Type;
    bits = 8;
    i = 0;
    while bits <= 64 {
        type: *Type_Info_Integer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Integer));
        type.id = KAI_TYPE_ID_INTEGER;
        type.is_signed = false;
        type.bits = bits;
        if bits == 8*sizeof(uint) {
            uint_type = type->Type;
        }
        if bits == 8 {
            u8_type = type->Type;
        }
        array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type->Type}, flags = KAI_NODE_EVALUATED});
        context.builtin_types.data[KAI_BUILTIN_S8 + i] = type->Type;
        bits *= 2;
        i += 1;
    }

    bits = 32;
    i = 0;
    while bits <= 64 {
        type: *Type_Info_Float = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Float));
        type.id = KAI_TYPE_ID_FLOAT;
        type.bits = bits;
        array_push(*context.nodes, Node.{type = type_type, value = Value.{type = type->Type}, flags = KAI_NODE_EVALUATED});
        context.builtin_types.data[KAI_BUILTIN_F32 + i] = type->Type;
        bits *= 2;
        i += 1;
    }

    bool_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    bool_type.id = KAI_TYPE_ID_BOOLEAN;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = bool_type->Type}, flags = KAI_NODE_EVALUATED});
    context.bool_type = bool_type;
    context.builtin_types.data[KAI_BUILTIN_BOOL] = bool_type;

    number_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
    number_type.id = KAI_TYPE_ID_NUMBER;
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = number_type}, flags = KAI_NODE_EVALUATED});
    context.number_type = number_type;
    context.builtin_types.data[KAI_BUILTIN_NUMBER] = number_type;

    pu8_type: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
    pu8_type.id = KAI_TYPE_ID_POINTER;
    pu8_type.sub_type = u8_type;
    string_type: *Type_Info_Struct = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Struct));
    string_type.id = KAI_TYPE_ID_STRING;
    string_type.size = sizeof(uint) + sizeof(*u8);
    string_type.fields.count = 2;
    string_type.fields.data = arena_allocate(*context.type_allocator, string_type.fields.count * sizeof(Struct_Field)) -> *Struct_Field;
    string_type.fields.data[0] = Struct_Field.{name = STRING("count"), offset = 0, type = uint_type};
    string_type.fields.data[1] = Struct_Field.{name = STRING("data"), offset = sizeof(uint), type = pu8_type->Type};
    array_push(*context.nodes, Node.{type = type_type, value = Value.{type = string_type->Type}, flags = KAI_NODE_EVALUATED});
    context.string_type = string_type -> Type;
    context.builtin_types.data[KAI_BUILTIN_STRING] = string_type -> Type;

    /*for i: 0..<context.builtin_types.count {
        type: Type = context.builtin_types.data[i];
        writer: *Writer = context.debug_writer;
        if writer != null {
            _write("type at ");
            _write_u32(i);
            _write(": ");
            write_type(writer, type);
            _write("\n");
        }
    }*/

    ret false;
}

_value_to_number :: (value: Value, type: *Type_Info, out_number: *Number) -> bool
{
    if type.id == {
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            num: Number = Number.{d = 1};
            if info.is_signed {
                num.is_neg = value.s64 < 0;
                if num.is_neg {
                    num.n = (-value.s64) -> u64;
                }
                else {
                    num.n = value.s64 -> u64;
                }
            }
            else {
                num.n = value.u64;
            }
            [out_number] = number_normalize(num);
            ret false;
        }

        case; {
            ret true;
        }
    }
}

_evaluate_binary_operation :: (op: u32, type: *Type_Info, a: Value, b: Value) -> Value
{
    if type.id == {
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            if info.is_signed {
                if info.bits == {
                    case 32; {
                        if op == {
                            case #char "+"; ret Value.{s32 = a.s32 + b.s32};
                            case #char "-"; ret Value.{s32 = a.s32 - b.s32};
                            case #char "*"; ret Value.{s32 = a.s32 * b.s32};
                        }
                    }
                }
            }
            else {
                if info.bits == {
                    case 64; {
                        if op == {
                            case #char "+"; ret Value.{u64 = a.u64 + b.u64};
                            case #char "-"; ret Value.{u64 = a.u64 - b.u64};
                        }
                    }
                }
            }
            kai__todo("integer op = %i, is_signed = %i, bits = %i", op, info.is_signed, info.bits);
        }
        case KAI_TYPE_ID_FLOAT; {
            info: *Type_Info_Float = cast type;
            if info.bits == {
                case 32; {
                    if op == {
                        case #char "+"; ret Value.{f32 = a.f32 + b.f32};
                        case #char "-"; ret Value.{f32 = a.f32 - b.f32};
                    }
                }
            }
            kai__todo("float op = %i, bits = %i", op, info.bits);
        }
        case KAI_TYPE_ID_NUMBER; {
            if op == {
                case #multi "=="; ret Value.{u8 = number_equals(a.number, b.number)};
                case #char "+"; ret Value.{number = number_add(a.number, b.number)};
                case #char "-"; ret Value.{number = number_sub(a.number, b.number)};
                case #char "*"; ret Value.{number = number_mul(a.number, b.number)};
                case #char "/"; ret Value.{number = number_div(a.number, b.number)};
                // TODO: shift must be by an unsigned integer
                case #multi "<<"; {
                    e: s64 = number_to_u64(b.number) -> s64;
                    ret Value.{number = number_normalize(Number.{a.number.n, a.number.d, a.number.e + e, a.number.is_neg})};
                }
                case #multi ">>"; {
                    e: s64 = number_to_u64(b.number) -> s64;
                    ret Value.{number = number_normalize(Number.{a.number.n, a.number.d, a.number.e - e, a.number.is_neg})};
                }
            }
            kai__todo("number op = %i", op);
        }
        case; {
            kai__todo("type.id = %i", type.id);
        }
    }
    ret Value.{0};
}

_add_dependency :: (context: *Compiler_Context, ref: Node_Reference)
{
    for i: 0..<context.current_dependencies.count {
        it: Node_Reference = context.current_dependencies.data[i];
        if it.index == ref.index && it.flags == ref.flags
            ret; // duplicate
    }
    allocator: *Allocator = *context.allocator;
    array_push(*context.current_dependencies, ref);
}

// NOTE: should this function always do type-checking?
// NOTE: expected_type WILL NOT be overwritten if [expected_type] != null
// NOTE: if out_value == null then only type-checking will occur
_value_of_expr :: (context: *Compiler_Context, expr: *Expr, out_value: *Value, expected_type: *Type) -> bool
{
    assert(expr != null);
    assert(expected_type != null);

    writer: *Writer = context.debug_writer;

    if expr.id == {
        case KAI_EXPR_IDENTIFIER; {
            ref: Node_Reference = _lookup_node(context, expr.source_code);

            if ref.flags & KAI_NODE_NOT_FOUND {
                location: Location = Location.{
                    source = context.current_source,
                    string = expr.source_code,
                    line = expr.line_number,
                };
                ret _error_not_declared(context, location);
            }

            if out_value == null {
                // Don't need node value
                ref.flags |= KAI_NODE_TYPE;
            }

            node_type: Type;
            node_value: Value;

            if ref.flags & KAI_NODE_LOCAL {
                if !(ref.flags & KAI_NODE_TYPE)
                    ret _error_fatal(context, STRING("cannot get value of a local node"));
                local_node: *Local_Node = *context.local_nodes.data[ref.index];
                node_type = local_node.type;
                if out_value == null {
                    asm_insert_stack_load(*context.assembler, local_node.stack_index, 0);
                }
                context.last_variable_index = local_node.stack_index;
            }
            else {
                node: *Node = *context.nodes.data[ref.index];
                if !(node.flags & KAI_NODE_TYPE_EVALUATED) {
                    if writer != null {
                        _write(" - this compilation depends on ");
                        _write_node_ref(context, ref);
                        _write("\n");
                    }
                    _add_dependency(context, ref);
                    ret true;
                }
                node_type = node.type;
                if out_value != null {
                    if !(node.flags & KAI_NODE_VALUE_EVALUATED) {
                        if writer != null {
                            _write(" - this compilation depends on ");
                            _write_node_ref(context, ref);
                            _write("\n");
                        }
                        _add_dependency(context, ref);
                        ret true;
                    }
                    node_value = node.value;
                }
            }

            if node_type == null {
                if writer != null {
                    _write(" - node: ");
                    _write_string(expr.source_code);
                    _write("\n");
                }
                ret _error_fatal(context, STRING("node type cannot be null"));
            }
            
            if [expected_type] != null {
                if [expected_type] != node_type
                    ret _error_type_check(context, expr, [expected_type], node_type);
            }
            else [expected_type] = node_type;
            
            expr.this_type = node_type;
            if out_value != null { [out_value] = node_value; }
            ret false;
        }

        case KAI_EXPR_NUMBER; {
            n: *Expr_Number = cast expr;
            if out_value == null {
                asm_insert_load_constant(*context.assembler, number_to_u64(n.value));
                if [expected_type] == null {
                    [expected_type] = context.number_type;
                    n.this_type = context.number_type;
                }
                else {
                    type: *Type_Info = [expected_type];
                    if type.id == {
                        case KAI_TYPE_ID_INTEGER;
                        case KAI_TYPE_ID_FLOAT;
                        case KAI_TYPE_ID_NUMBER;
                        case; {
                            if writer != null {
                                write_type(writer, type);
                                _write("\n");
                            }
                            ret _error_fatal(context, STRING("invalid number"));
                        }
                    }
                    n.this_type = [expected_type];
                }
                ret false;
            }
            if [expected_type] == null {
                [out_value] = Value.{number = n.value};
                [expected_type] = context.number_type;
                n.this_type = context.number_type;
            }
            else {
                // TODO: make sure number can be auto-cast to expected type
                type: *Type_Info = [expected_type];
                if type.id == {
                    case KAI_TYPE_ID_BOOLEAN; {
                        if !number_is_integer(n.value) || n.value.is_neg
                            ret _error_fatal(context, STRING("cannot convert to bool"));
                        value: u64 = number_to_u64(n.value);
                        if value > 1
                            ret _error_fatal(context, STRING("cannot convert to bool"));
                        out_value.u8 = value -> u8;
                    }
                    case KAI_TYPE_ID_INTEGER; {
                        if !number_is_integer(n.value)
                            ret _error_fatal(context, STRING("not integer"));
                        out_value.u64 = number_to_u64(n.value);
                    }
                    case KAI_TYPE_ID_FLOAT; {
                        type_info: *Type_Info_Float = cast type;
                        fv: f64 = number_to_f64(n.value);
                        if type_info.bits == 32
                            out_value.f32 = fv -> f32;
                        else
                            out_value.f64 = fv;
                    }
                    case KAI_TYPE_ID_NUMBER; {
                        out_value.number = n.value;
                    }
                    case; {
                        ret _error_fatal(context, STRING("cannot convert from number to unknown type"));
                    }
                }
                n.this_type = type;
            }
            ret false;
        }

        case KAI_EXPR_LITERAL; {
            assert([expected_type] != null);
            if out_value != null {
                kai__todo("generate literal value");
            }
            l: *Expr_Literal = cast expr;
            // Type must be struct, union, or array.
            expected: *Type_Info = [expected_type];
            if expected.id == {
            case KAI_TYPE_ID_ARRAY; {
                ai: *Type_Info_Array = cast expected;
                type: Type = ai.sub_type;
                assert(ai.cols == 1);
                count: u32 = 0;
                current: *Expr = l.head;
                while current != null {
                    if _value_of_expr(context, current, null, *type)
                        ret true;
                    count += 1;
                    current = current.next;
                }
                if count != ai.rows {
                    ret _error_fatal(context, STRING("array count mismatch"));
                }
            }
            case KAI_TYPE_ID_STRING;
            case KAI_TYPE_ID_STRUCT; {
                si: *Type_Info_Struct = cast expected;
                current: *Expr = l.head;
                while current != null {
                    if current.name.count == 0 {
                        ret _error_fatal(context, STRING("must use named assignments"));
                    }

                    type: Type;
                    for i: 0..<si.fields.count {
                        field: Struct_Field = si.fields.data[i];
                        if string_equals(current.name, field.name) {
                            type = field.type;
                            break;
                        }
                    }
                    if type == null {
                        ret _error_fatal(context, STRING("struct member not found"));
                    }
                    
                    if _value_of_expr(context, current, null, *type)
                        ret true;
                    current = current.next;
                }
            }
            case; {
                ret _error_type_check(context, expr, expected, context.type_type);
            }
            }
            expr.this_type = [expected_type];
            ret false;
        }

        case KAI_EXPR_STRING; {
            s: *Expr_String = cast expr;
            if [expected_type] == null {
                [expected_type] = context.string_type;
            }
            else if [expected_type] != context.string_type
                ret _error_type_check(context, expr, [expected_type], context.string_type);
            if out_value != null {
                [out_value] = Value.{string = s.value};
            }
            s.this_type = context.string_type;
            ret false;
        }

        case KAI_EXPR_ARRAY; {
            a: *Expr_Array = cast expr;

            type: *Type_Info;
            ev: Value;
            et: *Type_Info;
            if _value_of_expr(context, a.expr, *ev, *et)
                ret true;

            if et.id != KAI_TYPE_ID_TYPE
                ret _error_type_check(context, a.expr, context.type_type, et);
                
            rv: Value;
            if a.rows != null {
                rt: *Type_Info;
                if _value_of_expr(context, a.rows, *rv, *rt)
                    ret true;
                
                if rt.id == KAI_TYPE_ID_NUMBER {
                    ai: *Type_Info_Array = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Array));
                    ai.id = KAI_TYPE_ID_ARRAY;
                    assert(number_is_integer(rv.number));
                    ai.rows = number_to_u64(rv.number) -> u32;
                    ai.cols = 1;
                    ai.sub_type = ev.type;
                    type = ai -> Type;
                }
                else {
                    // map type (hash table) is implemented as struct of arrays
                    kai__todo("array type, type inside rows");
                }
            }
            else {
                kai__todo("need a slice type");
            }
            // TODO: use cols for matrices
            [out_value] = Value.{type = type};
            [expected_type] = context.type_type;
            ret false;
        }
        
        case KAI_EXPR_SPECIAL; {
            s: *Expr_Special = cast expr;
            type: *Type_Info;
            if s.kind == {
                case KAI_SPECIAL_TYPE; {
                    if out_value != null
                        out_value.type = context.type_type;
                    type = context.type_type;
                }
                case KAI_SPECIAL_NUMBER; {
                    if out_value != null
                        out_value.type = context.number_type;
                    type = context.type_type;
                }
                case KAI_SPECIAL_TRUE; {
                    if out_value != null
                        out_value.u8 = 1;
                    type = context.bool_type;
                }
                case KAI_SPECIAL_FALSE; {
                    if out_value != null
                        out_value.u8 = 0;
                    type = context.bool_type;
                }
                case; {
                    kai__todo("special value not implemented for %i", s.kind);
                }
            }
            if [expected_type] == null {
                [expected_type] = type;
            }
            else if [expected_type] != type
                ret _error_type_check(context, expr, [expected_type], type);
            s.this_type = type;
            ret false;
        }

        case KAI_EXPR_UNARY; {
            u: *Expr_Unary = cast expr;

            if u.op == {
                case #char "*"; {
                    // TODO: type checking is incomplete
                    expr_type: *Type_Info;
                    if _value_of_expr(context, u.expr, out_value, *expr_type)
                        ret true;

                    allocator: *Allocator = *context.allocator;
                        
                    // Pointer to type
                    if expr_type.id == KAI_TYPE_ID_TYPE {
                        checkpoint: Arena_Checkpoint = arena_save(*context.type_allocator);
                        pt: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
                        pt.id = KAI_TYPE_ID_POINTER;
                        pt.sub_type = out_value.type;
                        type: Type = pt->Type;

                        index: int = table_find(*context.type_cache, type);
                        if writer != null {
                            printf("index: %li ???\n", index);
                        }
                        if index != -1 {
                            type = context.type_cache.keys[index];
                            arena_restore(*context.type_allocator, checkpoint);
                        }
                        else {
                            table_set(*context.type_cache, pt->Type, 0);
                        }

                        if out_value != null
                            out_value.type = type;
                        _debug_show_type(context, type);
                        [expected_type] = context.type_type;
                        u.this_type = context.type_type;
                        ret false;
                    }
                    // Pointer to value
                    else {
                        pt: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
                        pt.id = KAI_TYPE_ID_POINTER;
                        pt.sub_type = expr_type;
                        if out_value != null
                            kai__todo("evaluate pointer to value");
                        _debug_show_type(context, pt->Type);
                        [expected_type] = pt -> Type;
                        u.this_type = pt -> Type;
                        ret false;
                    }
                }
                case #char "["; {
                    expr_type: *Type_Info;
                    if _value_of_expr(context, u.expr, out_value, *expr_type)
                        ret true;
                    if expr_type.id != KAI_TYPE_ID_POINTER
                        ret _error_fatal(context, STRING("can only dereference pointers"));
                    pt: *Type_Info_Pointer = cast expr_type;
                    if out_value != null
                        kai__todo("evaluate dereference");
                    [expected_type] = pt.sub_type;
                    u.this_type = pt.sub_type;
                    ret false;
                }
            }

            expr_type: *Type_Info = [expected_type];
            if _value_of_expr(context, u.expr, out_value, *expr_type)
                ret true;
            if out_value != null {
                kai__todo("evaluate unary operator");
            }
            [expected_type] = expr_type;
            u.this_type = expr_type;
            ret false;
        }

        case KAI_EXPR_BINARY; {
            b: *Expr_Binary = cast expr;

            lv: Value;
            rv: Value;

            out_lv: *Value;
            out_rv: *Value;
            if out_value != null {
                out_lv = *lv;
                out_rv = *rv;
            }

            if b.op == {
            case #multi "<<"; #through;
            case #multi ">>"; {
                lt: *Type_Info = [expected_type];
                if _value_of_expr(context, b.left, out_lv, *lt)
                    ret true;

                rt: *Type_Info;
                if _value_of_expr(context, b.right, out_rv, *rt)
                    ret true;

                if [expected_type] != null {
                    [expected_type] = lt;
                }
                b.this_type = lt;
                ret false;
            }
            case #multi "=="; #through;
            case #multi "!="; #through;
            case #multi "<"; #through;
            case #multi ">"; #through;
            case #multi "<="; #through;
            case #multi ">="; {
                expected: *Type_Info = [expected_type];
                if expected != null && expected.id != KAI_TYPE_ID_BOOLEAN
                    ret _error_type_check(context, expr, expected, context.bool_type);

                lt: *Type_Info;
                rt: *Type_Info;

                start: u32 = context.assembler.code.count;
                left_first: bool = true;

                if _value_of_expr(context, b.left, out_lv, *lt)
                    ret true;

                if lt.id == KAI_TYPE_ID_NUMBER {
                    left_first = false;
                    context.assembler.code.count = start;
                    if _value_of_expr(context, b.right, out_rv, *rt)
                        ret true;
                    context.stack_index += 1;
                    asm_insert_stack_store(*context.assembler, context.stack_index, 0);
                    lt = rt;
                    if _value_of_expr(context, b.left, out_lv, *lt)
                        ret true;
                    asm_insert_stack_load(*context.assembler, context.stack_index, 1);
                    context.stack_index -= 1;
                }
                else {
                    context.stack_index += 1;
                    asm_insert_stack_store(*context.assembler, context.stack_index, 0);
                    rt = lt;
                    if _value_of_expr(context, b.right, out_rv, *rt)
                        ret true;
                    asm_insert_stack_load(*context.assembler, context.stack_index, 1);
                    context.stack_index -= 1;
                }

                if lt != rt
                    ret _error_fatal(context, STRING("types no match, boolean comparison"));

                if left_first
                    asm_insert_cmp(*context.assembler, 1, 0);
                else
                    asm_insert_cmp(*context.assembler, 0, 1);
                
                // eor x0, x0, x0
                // cinc x0, x0, <cond>
                //asm_insert_bool_from_condition(*context.assembler, KAI_CONDITION_EQ);

                [expected_type] = context.bool_type;
                b.this_type = context.bool_type;
                ret false;
            }
            case #multi "->"; {
                lt: *Type_Info = null;
                if _value_of_expr(context, b.left, out_lv, *lt)
                    ret true;

                rt: *Type_Info = context.type_type;
                out_rv = *rv; // need value of right to output a type
                if _value_of_expr(context, b.right, out_rv, *rt)
                    ret true;

                if [expected_type] == null {
                    [expected_type] = rv.type;
                    b.this_type = rv.type;
                    ret false;
                }

                if [expected_type] != rv.type
                    ret _error_type_check(context, expr, [expected_type], rv.type);

                b.this_type = rv.type;
                ret false;
            }
            case #multi "."; {
                lt: *Type_Info;
                if _value_of_expr(context, b.left, out_lv, *lt)
                    ret true;

                if lt.id == {
                case KAI_TYPE_ID_TYPE; {
                    rt: *Type_Info;
                    if _value_of_expr(context, b.right, out_rv, *rt)
                        ret true;
                }
                case KAI_TYPE_ID_POINTER; {
                    pt: *Type_Info_Pointer = cast lt;
                    type: *Type_Info = cast pt.sub_type;
                    if type.id != KAI_TYPE_ID_STRUCT
                        ret _error_fatal(context, STRING("must be pointer to struct in member access"));
                    lt = type;
                } #through;
                case KAI_TYPE_ID_STRING; #through;
                case KAI_TYPE_ID_STRUCT; {
                    if b.right.id != KAI_EXPR_IDENTIFIER
                        ret _error_fatal(context, STRING("must be identifer in struct access"));

                    name: string = b.right.source_code;
                    st: *Type_Info_Struct = cast lt;
                    for i: 0..<st.fields.count {
                        field: Struct_Field = st.fields.data[i];
                        if string_equals(name, field.name) {
                            if [expected_type] != null && [expected_type] != field.type
                                ret _error_type_check(context, expr, [expected_type], field.type);
                            [expected_type] = field.type;
                            b.this_type = field.type;
                            ret false;
                        }
                    }

                    ret _error_no_member(context, lt, b.right);
                }
                case; {
                    kai__todo("need to implement (left type id: %i)", lt.id);
                }
                }
            }
            case #multi "["; {
                if out_value != null
                    ret _error_fatal(context, STRING("value not implemented for index operation"));

                lt: *Type_Info = null;
                if _value_of_expr(context, b.left, null, *lt)
                    ret true;

                if lt.id != KAI_TYPE_ID_POINTER
                    ret _error_fatal(context, STRING("left side of index is not a pointer"));

                pt: *Type_Info_Pointer = cast lt;

                rt: *Type_Info;
                if _value_of_expr(context, b.right, null, *rt)
                    ret true;

                if rt.id == {
                    case KAI_TYPE_ID_INTEGER; #through;
                    case KAI_TYPE_ID_NUMBER; {
                        // good
                    }
                    case; {
                        ret _error_fatal(context, STRING("must index by a integer value"));
                    }
                }

                if [expected_type] == null {
                    [expected_type] = pt.sub_type;
                }
                else if [expected_type] != pt.sub_type
                    ret _error_type_check(context, expr, [expected_type], pt.sub_type);

                b.this_type = pt.sub_type;
                ret false;
            }
            }

            lt: *Type_Info = [expected_type];
            rt: *Type_Info = [expected_type];

            start: u32 = context.assembler.code.count;
            left_first: bool = true;

            if _value_of_expr(context, b.left, out_lv, *lt)
                ret true;

            if lt.id == KAI_TYPE_ID_NUMBER {
                left_first = false;
                context.assembler.code.count = start;
                if _value_of_expr(context, b.right, out_rv, *rt)
                    ret true;
                context.stack_index += 1;
                asm_insert_stack_store(*context.assembler, context.stack_index, 0);
                lt = rt;
                if _value_of_expr(context, b.left, out_lv, *lt)
                    ret true;
                asm_insert_stack_load(*context.assembler, context.stack_index, 1);
                context.stack_index -= 1;
            }
            else {
                context.stack_index += 1;
                asm_insert_stack_store(*context.assembler, context.stack_index, 0);
                rt = lt;
                if _value_of_expr(context, b.right, out_rv, *rt)
                    ret true;
                asm_insert_stack_load(*context.assembler, context.stack_index, 1);
                context.stack_index -= 1;
            }

            if b.op == {
                case #char "+"; {
                    asm_insert_add(*context.assembler, 0, 0, 1);
                }
                case #char "-"; {
                    if left_first
                        asm_insert_sub(*context.assembler, 0, 1, 0);
                    else
                        asm_insert_sub(*context.assembler, 0, 0, 1);
                }
            }

            if lt != rt
                ret _error_fatal(context, STRING("types no match, comparison"));
                
            if out_value != null {
                value: Value = _evaluate_binary_operation(b.op, lt, lv, rv);
                type: *Type_Info = context.number_type;

                [out_value] = value;
                if lt.id == KAI_TYPE_ID_NUMBER {
                    if type.id == {
                        case KAI_TYPE_ID_BOOLEAN; {
                            if value.number.n != 0 && (value.number.n != 1 || value.number.d != 1 || value.number.e != 0 || value.number.is_neg != 0)
                                ret _error_fatal(context, STRING("cannot convert number to bool"));
                            out_value.u8 = value.number.n -> u8;
                            ret false;
                        }
                        case KAI_TYPE_ID_INTEGER; {
                            // TODO: bounds check
                            out_value.u64 = number_to_u64(value.number);
                            ret false;
                        }
                        case KAI_TYPE_ID_FLOAT; {
                            // TODO: bounds check
                            type_info: *Type_Info_Float = cast type;
                            fv: f64 = number_to_f64(value.number);
                            if type_info.bits == 32
                                out_value.f32 = fv -> f32;
                            else
                                out_value.f64 = fv;
                            ret false;
                        }
                    }
                }
            }
            [expected_type] = lt;
            b.this_type = lt;
            ret false;
        }

        case KAI_EXPR_PROCEDURE; {
            allocator: *Allocator = *context.allocator;
            p: *Expr_Procedure = cast expr;

            assert([expected_type] != null);
            pt: *Type_Info_Procedure = cast [expected_type];
            assert(pt.id == KAI_TYPE_ID_PROCEDURE);

            // Setup procedure scope
            array_push(*context.scopes, Scope.{ is_proc_scope = true });
            scope: *Scope = *array_last(*context.scopes);
            prev_node_count: u32 = context.nodes.count;
            local_node_count: u32 = context.local_nodes.count;
            
            // Compile procedure body as compilation unit
            if _create_nodes(context, p.body)
                ret true;
            if _compile_all_nodes_in_scope(context)
                ret true;

            // Insert local nodes for procedure input
            current: *Expr = p.in_out_expr;
            for i: 0..<p.in_count {
                type: Type = pt.inputs.data[i];
                ref: Node_Reference = Node_Reference.{
                    flags = KAI_NODE_LOCAL,
                    index = context.local_nodes.count,
                };
                array_push(*context.local_nodes, Local_Node.{
                    type = type,
                    location = Location.{
                        string = current.name,
                        line = current.line_number
                    },
                });
                table_set(*scope.identifiers, current.name, ref);
                current = current.next;
            }

            if out_value != null {
                if context.options.flags & KAI_COMPILE_NO_CODE_GEN
                    out_value.ptr = p;
                else
                    out_value.u32 = asm_create_label(*context.assembler);
            }

            // Type-check procedure body
            if p.body.id == KAI_STMT_COMPOUND {
                c: *Stmt_Compound = cast p.body;
                current: *Stmt = c.head;
                while current {
                    // TODO: are these all the nodes we need to skip?
                    if current.id == KAI_STMT_DECLARATION
                    && current.flags & KAI_FLAG_DECL_CONST
                        continue;

                    t: *Type_Info;
                    if pt.outputs.count != 0 {
                        t = pt.outputs.data[0]; // HACK
                    }
                    if current.id == KAI_STMT_DECLARATION {
                        t = null;
                    }
                    if _value_of_expr(context, current, null, *t)
                        ret true;

                    current = current.next;
                }
            }
            else kai__todo("non compound procedures");

            array_pop(*context.scopes);
            context.nodes.count = prev_node_count;
            context.local_nodes.count = local_node_count;
            p.this_type = [expected_type]; // ???
            ret false;
        }

        case KAI_EXPR_STRUCT; {
            s: *Expr_Struct = cast expr;
            st: *Type_Info_Struct = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Struct));
            st.id = KAI_TYPE_ID_STRUCT;
            // TODO: need to calculate real field count
            st.fields.count = s.field_count;
            st.fields.data = arena_allocate(*context.type_allocator, sizeof(Struct_Field) * st.fields.count) -> *Struct_Field;
            st.size = 0;

            // HACK
            node: *Node = *context.nodes.data[context.current_node.index];
            node.flags |= KAI_NODE_VALUE_EVALUATED;
            node.value.type = st -> Type;

            current: *Expr = s.head;
            for i: 0..<s.field_count {
                assert(current.id == KAI_STMT_DECLARATION);
                d: *Stmt_Declaration = cast current;

                type: *Type_Info;
                value: Value;
                if _value_of_expr(context, d.type, *value, *type) {
                    node.flags &=~ KAI_NODE_VALUE_EVALUATED;
                    ret true;
                }
                if type.id != KAI_TYPE_ID_TYPE {
                    node.flags &=~ KAI_NODE_VALUE_EVALUATED;
                    ret true;
                }

                st.fields.data[i] = Struct_Field.{
                    name = d.name,
                    offset = st.size,
                    type = value.type,
                };
                st.size += _type_size(value.type);
                current = current.next;
            }

            out_value.type = st -> Type;
            [expected_type] = context.type_type;
            ret false;
        }

        case KAI_EXPR_ENUM; {
            e: *Expr_Enum = cast expr;

            sv: Value;
            st: *Type_Info;
            if _value_of_expr(context, e.type, *sv, *st)
                ret true;

            if st.id != KAI_TYPE_ID_TYPE
                kai__todo("enum backing type must be type");
            if sv.type.id != KAI_TYPE_ID_INTEGER
                kai__todo("non integral enum type");

            et: *Type_Info_Enum = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Enum));
            et.id = KAI_TYPE_ID_ENUM;
            et.sub_type = sv.type;
            et.values.count = e.field_count;
            et.values.data = arena_allocate(*context.type_allocator, sizeof(Enum_Value) * et.values.count) -> *Enum_Value;

            current: *Expr = e.head;
            for i: 0..<e.field_count {
                assert(current.id == KAI_STMT_DECLARATION);
                d: *Stmt_Declaration = cast current;

                type: *Type_Info = sv.type;
                value: Value;
                if _value_of_expr(context, d.value, *value, *type)
                    ret true;
                
                // TODO: need to save all values
                //ASSERT(type.id == KAI_TYPE_ID_NUMBER);
                //et.values.data[i] = Enum_Value.{
                //    name = d.name,
                //    value = number_to_u64(value.number),
                //};
                current = current.next;
            }

            out_value.type = et -> Type;
            [expected_type] = context.type_type;
            ret false;
        }
        
        case KAI_EXPR_PROCEDURE_TYPE; {
            p: *Expr_Procedure_Type = cast expr;
            
            pt: *Type_Info_Procedure = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Procedure));
            pt.id = KAI_TYPE_ID_PROCEDURE;
            pt.inputs.count = p.in_count;
            pt.inputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.inputs.count) -> *Type;
            pt.outputs.count = p.out_count;
            pt.outputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.outputs.count) -> *Type;

            current: *Expr = p.in_out_expr;
            for i: 0..<p.in_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expr(context, current, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret _error_type_check(context, current, context.type_type, type);
                pt.inputs.data[i] = value.type;
                current = current.next;
            }
            for i: 0..<p.out_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expr(context, current, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret _error_type_check(context, current, context.type_type, type);
                if value.type.id == KAI_TYPE_ID_VOID && p.out_count == 1 {
                    pt.outputs.count = 0;
                    break;
                }
                // TODO: allocate output types here
                pt.outputs.data[i] = value.type;
                current = current.next;
            }

            out_value.type = pt -> Type;
            [expected_type] = context.type_type;
            ret false;
        }

        case KAI_EXPR_PROCEDURE_CALL; {
            c: *Expr_Procedure_Call = cast expr;

            // TODO: Something else needs to happen here to actually call the procedure
            // when an output value is required.
            assert(out_value == null);

            t: *Type_Info;
            if _value_of_expr(context, c.proc, null, *t)
                ret true;

            assert(t.id == KAI_TYPE_ID_PROCEDURE);
            pt: *Type_Info_Procedure = cast t;

            assert(c.arg_count == pt.inputs.count);

            current: *Expr = c.arg_head;
            for i: 0..<pt.inputs.count {
                input_type: Type = pt.inputs.data[i];
                if _value_of_expr(context, current, null, *input_type)
                    ret true;
                current = current.next;
            }

            output_type: Type = context.builtin_types.data[KAI_BUILTIN_VOID];
            if pt.outputs.count > 0 {
                output_type = pt.outputs.data[0];
            }

            if [expected_type] == null {
                [expected_type] = output_type;
            }
            if [expected_type] != output_type
                ret _error_type_check(context, expr, [expected_type], output_type);

            expr.this_type = output_type;
            ret false;
        }

        case KAI_STMT_COMPOUND; {
            // TODO: need to have a compilation unit here.
            // Maybe only when there are const nodes..
            allocator: *Allocator = *context.allocator;
            array_push(*context.scopes, Scope.{});
            
            c: *Stmt_Compound = cast expr;
            current: *Stmt = c.head;
            while current != null {
                t: Type = [expected_type];
                if _value_of_expr(context, current, null, *t)
                    ret true;
                current = current.next;
            }
            
            array_pop(*context.scopes);
            ret false;
        }

        case KAI_STMT_RETURN; {
            assert(out_value == null); // return does not have a value

            r: *Stmt_Return = cast expr;
            if r.expr != null {
                if _value_of_expr(context, r.expr, null, expected_type)
                    ret true;
            } else {
                // TODO: need to make sure that function does not have a return
            }
            asm_insert_ret(*context.assembler);
            ret false;
        }

        case KAI_STMT_DECLARATION; {
            allocator: *Allocator = *context.allocator;
            d: *Stmt_Declaration = cast expr;

            //assert([expected_type] == null);

            type: *Type_Info;
            if d.type != null {
                v: Value;
                if _value_of_expr(context, d.type, *v, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret _error_type_check(context, d.type, context.type_type, type);
                type = v.type;
            }

            if d.value != null {
                if _value_of_expr(context, d.value, null, *type)
                    ret true;
            }

            if out_value == null {
                context.stack_index += 1;
                asm_insert_stack_store(*context.assembler, context.stack_index, 0);
            }

            ref: Node_Reference = Node_Reference.{
                flags = KAI_NODE_LOCAL,
                index = context.local_nodes.count,
            };
            array_push(*context.local_nodes, Local_Node.{
                type = type,
                location = Location.{
                    string = d.name,
                    line = d.line_number,
                },
                stack_index = context.stack_index,
            });
            // TODO: NO OVERWRITING
            scope: *Scope = *array_last(*context.scopes);
            table_set(*scope.identifiers, d.name, ref);

            d.this_type = type;
        //    [expected_type] = type;
            ret false;
        }

        case KAI_STMT_ASSIGNMENT; {
            a: *Stmt_Assignment = cast expr;
            type: *Type_Info;
            start: u32 = context.assembler.code.count;
            if _value_of_expr(context, a.dest, null, *type)
                ret true;
            stack_index: u32 = context.last_variable_index;
            context.assembler.code.count = start;
            if _value_of_expr(context, a.value, null, *type)
                ret true;
            if out_value == null {
                asm_insert_stack_store(*context.assembler, stack_index, 0);
            }
            ret false;
        }

        case KAI_STMT_IF; {
            i: *Stmt_If = cast expr;

            type: *Type_Info = context.bool_type;
            if _value_of_expr(context, i.condition, null, *type)
                ret true;
            asm_insert_test(*context.assembler, 0);
            then_jump: u32 = asm_insert_jump(*context.assembler, KAI_CONDITION_EQ, 0);
            if _value_of_expr(context, i.then_body, null, expected_type)
                ret true;
            end_jump: u32 = asm_insert_jump(*context.assembler, KAI_CONDITION_AL, 0);
            then_label: u32 = asm_create_label(*context.assembler);
            if i.else_body != null {
                if _value_of_expr(context, i.else_body, null, expected_type)
                    ret true;
            }
            end_label: u32 = asm_create_label(*context.assembler);
            then_relative: s32 = asm_relative_location(then_jump, then_label);
            end_relative: s32 = asm_relative_location(end_jump, end_label);
            asm_modify_jump(*context.assembler, then_jump, then_relative);
            asm_modify_jump(*context.assembler, end_jump, end_relative);
            ret false;
        }

        case KAI_STMT_WHILE; {
            w: *Stmt_While = cast expr;

            type: *Type_Info = context.bool_type;
            if _value_of_expr(context, w.condition, null, *type)
                ret true;
            if _value_of_expr(context, w.body, null, expected_type)
                ret true;
            ret false;
        }

        case KAI_STMT_FOR; {
            f: *Stmt_For = cast expr;

            assert(f.from != null);
            assert(f.to != null);

            // HACK (logic is very similar to binary comparisons, so reuse same logic)
            b_expr: Expr_Binary = Expr_Binary.{
                id = KAI_EXPR_BINARY,
                op = #char "<",
                left = f.from,
                right = f.to,
            };
            type: *Type_Info;
            if _value_of_expr(context, *b_expr -> *Expr, null, *type)
                ret true;

            allocator: *Allocator = *context.allocator;
            ref: Node_Reference = Node_Reference.{
                flags = KAI_NODE_LOCAL,
                index = context.local_nodes.count,
            };
            array_push(*context.local_nodes, Local_Node.{
                type = f.from.this_type,
                location = Location.{
                    string = f.iterator_name,
                    line = f.line_number
                },
            });
            array_push(*context.scopes, Scope.{});
            scope: *Scope = *array_last(*context.scopes);
            table_set(*scope.identifiers, f.iterator_name, ref);

            if _value_of_expr(context, f.body, null, expected_type)
                ret true;

            array_pop(*context.scopes);
            ret false;
        }

        case; {
            kai__todo("%s (expr.id = %i)", __FUNCTION__, expr.id);
        }
    }

    ret true;
}

_write_node_ref :: (context: *Compiler_Context, ref: Node_Reference)
{
    writer: *Writer = context.debug_writer;
    node: *Node = *context.nodes.data[ref.index];
    if ref.flags & KAI_NODE_TYPE {
        _set_color(KAI_WRITE_COLOR_TYPE);
        _write("T(");
    }
    else _write("V(");
    _set_color(KAI_WRITE_COLOR_IMPORTANT);
    _write_string(node.location.string);
    _set_color(KAI_WRITE_COLOR_DEFAULT);
    if ref.flags & KAI_NODE_TYPE {
        _set_color(KAI_WRITE_COLOR_TYPE);
        _write(")");
        _set_color(KAI_WRITE_COLOR_DEFAULT);
    }
    else _write(")");
}

_type_of_expression :: (context: *Compiler_Context, expr: *Expr, out_type: *Type) -> bool
{
    assert(expr != null);

    writer: *Writer = context.debug_writer;

    if expr.id == {
        case KAI_EXPR_IDENTIFIER; {
            ref: Node_Reference = _lookup_node(context, expr.source_code);

            if ref.flags & KAI_NODE_NOT_FOUND {
                location: Location = Location.{
                    source = context.current_source,
                    string = expr.source_code,
                    line = expr.line_number,
                };
                ret _error_not_declared(context, location);
            }

            node: *Node = *context.nodes.data[ref.index];
            
            if !(node.flags & KAI_NODE_TYPE_EVALUATED) {
                ref.flags |= KAI_NODE_TYPE;
                // NOTE: We want to depend on the type of whatever this thing is.
                if writer != null {
                    _write(" - this compilation depends on ");
                    _write_node_ref(context, ref);
                    _write("\n");
                }
                _add_dependency(context, ref);
                ret true;
            }
            if writer != null {
                _write("node.type ");
                _write_string(node.location.string);
                _write(" ");
                write_type(writer, node.type);
                _write("\n");
            }
            [out_type] = node.type;
            ret false;
        }

        case KAI_EXPR_NUMBER; {
            // TODO: make better
            ref: Node_Reference = _lookup_node(context, STRING("s32"));
            assert(!(ref.flags & KAI_NODE_NOT_FOUND));
            node: *Node = *context.nodes.data[ref.index];
            [out_type] = node.value.type;
            ret false;
        }

        case KAI_EXPR_STRING; {
            [out_type] = context.string_type;
            ret false;
        }

        case KAI_EXPR_SPECIAL; {
            s: *Expr_Special = cast expr;
            if s.kind == {
                case KAI_SPECIAL_NUMBER; #through;
                case KAI_SPECIAL_TYPE; {
                    [out_type] = context.type_type;
                    ret false;
                }
                case KAI_SPECIAL_TRUE; #through;
                case KAI_SPECIAL_FALSE; {
                    [out_type] = context.bool_type;
                    ret false;
                }
            }
            kai__todo("special value not implemented");
        }

        case KAI_EXPR_UNARY; {
            u: *Expr_Unary = cast expr;
            et: *Type_Info;
            if _type_of_expression(context, u.expr, *et)
                ret true;

            if u.op == #char "*" {
                // Pointer to a type, is still a type
                if et.id == KAI_TYPE_ID_TYPE {
                    [out_type] = et;
                    ret false;
                }
                pt: *Type_Info_Pointer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Pointer));
                pt.id = KAI_TYPE_ID_POINTER;
                pt.sub_type = et;
                _debug_show_type(context, pt->Type);
                [out_type] = pt->Type;
                ret false;
            }

            [out_type] = et;
            ret false;
        }

        case KAI_EXPR_BINARY; {
            b: *Expr_Binary = cast expr;
            if b.op == #multi "->" {
                rv: Value;
                rt: *Type_Info;

                if _value_of_expr(context, b.right, *rv, *rt)
                    ret true;

                if rt.id != KAI_TYPE_ID_TYPE
                    kai__todo("must cast to a type");

                [out_type] = rv.type;
                ret false;
            }
            lt: *Type_Info;
            rt: *Type_Info;
            if _type_of_expression(context, b.left, *lt) ret true;
            if _type_of_expression(context, b.right, *rt) ret true;
            if lt != rt {
                if lt.id == KAI_TYPE_ID_NUMBER {
                    [out_type] = rt;
                    ret false;
                }
                if rt.id == KAI_TYPE_ID_NUMBER {
                    [out_type] = lt;
                    ret false;
                }
                if writer != null {
                    _write("left: ");
                    write_type(writer, lt);
                    _write("\nright: ");
                    write_type(writer, rt);
                    _write("\n");
                }
                kai__todo("binary expression with different types");
            }
            [out_type] = lt;
            ret false;
        }

        case KAI_EXPR_PROCEDURE; {
            p: *Expr_Procedure = cast expr;
            
            pt: *Type_Info_Procedure = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Procedure));
            pt.id = KAI_TYPE_ID_PROCEDURE;
            pt.inputs.count = p.in_count;
            pt.inputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.inputs.count) -> *Type;
            pt.outputs.count = p.out_count;
            pt.outputs.data = arena_allocate(*context.type_allocator, sizeof(Type) * pt.outputs.count) -> *Type;

            current: *Expr = p.in_out_expr;
            for i: 0..<p.in_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expr(context, current, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret _error_type_check(context, current, context.type_type, type);
                pt.inputs.data[i] = value.type;
                current = current.next;
            }
            for i: 0..<p.out_count {
                type: *Type_Info;
                value: Value;
                if _value_of_expr(context, current, *value, *type)
                    ret true;
                if type.id != KAI_TYPE_ID_TYPE
                    ret _error_type_check(context, current, context.type_type, type);
                pt.outputs.data[i] = value.type;
                current = current.next;
            }

            [out_type] = pt -> Type;
            ret false;
        }
        
        case KAI_EXPR_STRUCT; #through;
        case KAI_EXPR_ENUM; #through;
        case KAI_EXPR_PROCEDURE_TYPE; {
            [out_type] = context.type_type;
            ret false;
        }

        case KAI_EXPR_PROCEDURE_CALL; {
            // TODO: HACK
            ref: Node_Reference = _lookup_node(context, STRING("u32"));
            u32_node: *Node = *context.nodes.data[ref.index];
            [out_type] = u32_node.value.type;
            ret false;
        }

        case; {
            kai__todo("%s (expr.id = %i)", __FUNCTION__, expr.id);
        }
    }

    ret false;
}

_find_host_import :: (context: *Compiler_Context, name: string) -> *Import
{
    for i: 0..<context.imports.count {
        import: *Import = *context.imports.data[i];
        if string_equals(import.name, name)
            ret import;
    }
    ret null;
}

_type_expression_from_string :: (context: *Compiler_Context, s: string) -> *Expr
{
    parser: Parser;
    parser.tokenizer.source = s;
    parser.tokenizer.line_number = 1;
    parser.error = context.error;
    parser.arena = context.temp_allocator;

    tokenizer_next(*parser.tokenizer);
    type: *Expr = parse_type_expression(*parser);

    if type == null {
        _error_fatal(context, STRING("could not parse string"));
        ret null;
    }

    context.temp_allocator = parser.arena;
    ret type;
}

// ret #size(type)  (bytes)
_type_size :: (type: *Type_Info) -> u32
{
    if type == null
        kai__todo("type cannot be null");
    if type.id == {
        case KAI_TYPE_ID_TYPE; {
            ret sizeof(Type);
        }
        case KAI_TYPE_ID_BOOLEAN; {
            ret 1;
        }
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            ret info.bits / 8;
        }
        case KAI_TYPE_ID_FLOAT; {
            info: *Type_Info_Float = cast type;
            ret info.bits / 8;
        }
        case KAI_TYPE_ID_POINTER; #through;
        case KAI_TYPE_ID_PROCEDURE; {
            ret sizeof(*void);
        }
        case KAI_TYPE_ID_ARRAY; {
            info: *Type_Info_Array = cast type;
            ret info.rows * info.cols * _type_size(info.sub_type);
        }
        case KAI_TYPE_ID_STRING; #through;
        case KAI_TYPE_ID_STRUCT; {
            info: *Type_Info_Struct = cast type;
            ret info.size;
        }
        case KAI_TYPE_ID_ENUM; {
            info: *Type_Info_Enum = cast type;
            ret _type_size(info.sub_type);
        }
        case KAI_TYPE_ID_NUMBER; {
            ret sizeof(Number);
        }
    }

    kai__todo("type.id = %i", type.id);
    ret 0;
}

_copy_value :: (out: *u8, type: *Type_Info, value: Value)
{
    if type.id == {
        case KAI_TYPE_ID_TYPE; {
            [out -> *Type] = value.type;
        }
        case KAI_TYPE_ID_BOOLEAN; {
            [out -> *bool] = value.u8;
        }
        case KAI_TYPE_ID_INTEGER; {
            info: *Type_Info_Integer = cast type;
            if info.is_signed {
                if info.bits == {
                    case  8; [out -> *s8]  = value.s8;
                    case 16; [out -> *s16] = value.s16;
                    case 32; [out -> *s32] = value.s32;
                    case 64; [out -> *s64] = value.s64;
                }
            }
            else {
                if info.bits == {
                    case  8; [out -> *u8]  = value.u8;
                    case 16; [out -> *u16] = value.u16;
                    case 32; [out -> *u32] = value.u32;
                    case 64; [out -> *u64] = value.u64;
                }
            }
        }
        case KAI_TYPE_ID_FLOAT; {
            info: *Type_Info_Float = cast type;
            if info.bits == {
                case 32; [out -> *f32] = value.f32;
                case 64; [out -> *f64] = value.f64;
            }
        }
        case KAI_TYPE_ID_POINTER; #through;
        case KAI_TYPE_ID_PROCEDURE; {
            [out -> **void] = value.ptr;
        }
        case KAI_TYPE_ID_STRING; {
            [out -> *string] = value.string;   
        }
        case KAI_TYPE_ID_STRUCT; {
            info: *Type_Info_Struct = cast type;
            if info.size <= sizeof(Value)
                _memory_copy(out, value.inline_struct, info.size);
            else
                _memory_copy(out, value.ptr, info.size);
        }
        case KAI_TYPE_ID_NUMBER; {
            [out -> *Number] = value.number;
        }
        case; {
            kai__todo("type.id = %i", type.id);
        }
    }
}

_push_value :: (context: *Compiler_Context, type: *Type_Info, value: Value) -> u32
{
    allocator: *Allocator = *context.allocator;
    size: u32 = _max_u32(_type_size(type), 8);
    location: u32 = context.program.data.count;
    array_grow(*context.program.data, size);
    _copy_value(context.program.data.data + location, type, value);
    context.program.data.count += size;
    ret location;
}

_node_reference_equals :: (a: Node_Reference, b: Node_Reference) -> bool
{
    ret ((a.flags&(~KAI_NODE_VISITED)) == (b.flags&(~KAI_NODE_VISITED))) && (a.index == b.index);
}

_explore_nodes :: (context: *Compiler_Context, pending: *Pending_Node) -> bool
{
    allocator: *Allocator = *context.allocator;
    scope: *Scope = *array_last(*context.scopes);

    pending.ref.flags |= KAI_NODE_VISITED;

    for i: 0..<pending.dependencies.count {
        dep: Node_Reference = pending.dependencies.data[i];
        if _node_reference_equals(dep, context.current_node) {
            array_push(*context.current_dependencies, context.current_node);
            ret _error_circular_dependency(context);
        }
        for j: 0..<scope.pending_nodes.count {
            other: *Pending_Node = *scope.pending_nodes.data[j];
            if !(other.ref.flags & KAI_NODE_VISITED)
            && _node_reference_equals(other.ref, dep) {
                array_push(*context.current_dependencies, other.ref);
                if _explore_nodes(context, other)
                    ret true;
                array_pop(*context.current_dependencies);
            }
        }
    }

    pending.ref.flags &= (~KAI_NODE_VISITED);
    ret false;
}

_compile_all_nodes_in_scope :: (context: *Compiler_Context) -> bool
{
    allocator: *Allocator = *context.allocator;
    writer: *Writer = context.debug_writer;
    scope: *Scope = *array_last(*context.scopes);

    while scope.pending_nodes.count > 0 {
        pending: Pending_Node = scope.pending_nodes.data[0];
        array_remove(*scope.pending_nodes, 0);

        for i: 0..<pending.dependencies.count {
            dep: Node_Reference = pending.dependencies.data[i];
            node: *Node = *context.nodes.data[dep.index];
            if dep.flags & KAI_NODE_TYPE {
                if node.flags & KAI_NODE_TYPE_EVALUATED {
                    array_remove(*pending.dependencies, i);
                    i -= 1;
                }
            }
            else {
                if node.flags & KAI_NODE_VALUE_EVALUATED {
                    array_remove(*pending.dependencies, i);
                    i -= 1;
                }
            }
        }

        context.current_node = pending.ref;

        if pending.dependencies.count != 0
        {
            if writer != null {
                _write("dependencies for ");
                _write_node_ref(context, pending.ref);
                _write(" are not resolved: ");
                for i: 0..<pending.dependencies.count {
                    dep: Node_Reference = pending.dependencies.data[i];
                    _write_node_ref(context, dep);
                    _write(" ");
                }
                _write("\n");
                for i: 0..<scope.pending_nodes.count {
                    pending: Pending_Node = scope.pending_nodes.data[i];
                    _write(".. ");
                    _write_node_ref(context, pending.ref);
                    _write(" depends on ");
                    for i: 0..<pending.dependencies.count {
                        dep: Node_Reference = pending.dependencies.data[i];
                        _write_node_ref(context, dep);
                        _write(" ");
                    }
                    _write("\n");
                }
            }

            if _explore_nodes(context, *pending)
                ret true;
            array_push(*scope.pending_nodes, pending);
            context.current_dependencies.count = 0;
            continue;
        }

        node: *Node = *context.nodes.data[pending.ref.index];
        context.current_source = node.location.source;

        if writer != NULL {
            _write("compiling ");
            _write_node_ref(context, pending.ref);
            _write("\n");
        }
        if pending.ref.flags & KAI_NODE_TYPE {
            type_value: Value;
            type_type: Type = context.type_type; // TODO: remove
            failed: bool;
            if node.type_expr != null
                failed = _value_of_expr(context, node.type_expr, *type_value, *type_type);
            else
                failed = _type_of_expression(context, node.value_expr, *type_value.type);
            node.type = type_value.type;

            if failed {
                if context.error.result != KAI_SUCCESS
                    ret true;
                array_push(*scope.pending_nodes, Pending_Node.{ref = pending.ref, dependencies = context.current_dependencies});
                // TODO: move this?
                context.current_dependencies.data = null;
                context.current_dependencies.count = 0;
                context.current_dependencies.capacity = 0;
            }
            else {
                node.decl.this_type = node.type;
                node.flags |= KAI_NODE_TYPE_EVALUATED;
            }
            if writer != NULL {
                printf("=> ");
                write_type(writer, node.type);
                printf("\n");
            }
        } else {
            assert(node.type != null);
            type: Type = node.type; // TODO: remove
            if node.value_expr != null && _value_of_expr(context, node.value_expr, *node.value, *type) {
                if context.error.result != KAI_SUCCESS
                    ret true;
                array_push(*scope.pending_nodes, Pending_Node.{ref = pending.ref, dependencies = context.current_dependencies});
                // TODO: move this?
                context.current_dependencies.data = null;
                context.current_dependencies.count = 0;
                context.current_dependencies.capacity = 0;
                continue;
            }
            else {
                node.flags |= KAI_NODE_VALUE_EVALUATED;
            }
            if writer != NULL {
                printf("=> ");
                if node.type.id == {
                    case KAI_TYPE_ID_TYPE; {
                        write_type(writer, node.value.type);
                    }
                    case KAI_TYPE_ID_NUMBER; {
                        kai_write_number(writer, node.value.number);
                    }
                    case KAI_TYPE_ID_INTEGER; {
                        info: *Type_Info_Integer = cast node.type;
                        if info.is_signed _write_s64(node.value.s64);
                        else _write_u64(node.value.u64);
                    }
                    case KAI_TYPE_ID_FLOAT; {
                        //info: *Type_Info_Float = cast node.type;
                        _write_f64(node.value.f32 -> f64);
                    }
                    case KAI_TYPE_ID_PROCEDURE; {
                        _write("0x");
                        context.debug_writer.write(context.debug_writer.user, KAI_WRITE_U64,
                            Value.{u64 = node.value.u64}, Write_Format.{flags = KAI_WRITE_FLAGS_BASE_16});
                    }
                }
                printf("\n");
            }
        }

        if (node.flags & (KAI_NODE_EXPORT|KAI_NODE_EVALUATED)) == (KAI_NODE_EXPORT|KAI_NODE_EVALUATED) {
            if writer != NULL {
                _write("exporting ");
                _write_string(node.location.string);
                _write(" [");
                write_type(writer, node.type);
                _write("]\n");
            }

            location: u32 = _push_value(context, node.type, node.value);
            table_set(*context.program.variable_table, node.location.string, Variable.{type = node.type, location = location});
        }
    }
    ret false;
}

create_program :: (info: *Program_Create_Info, out_program: *Program) -> Result
{
    // context := defer create_context(info);
    context: Compiler_Context = Compiler_Context.{
        error = info.error,
        allocator = info.allocator,
        program = out_program,
        options = info.options,
        imports = info.imports,
        debug_writer = info.debug_writer,
    };
    arena_create(*context.type_allocator, *info.allocator);
    arena_create(*context.temp_allocator, *info.allocator);
    context.error_arena.allocator = info.allocator;
    context.assembler.allocator = *info.allocator;

    if !(info.options.flags & KAI_COMPILE_NO_CODE_GEN)
        context.assembler.backend = KAI_BACKEND_ARM64;

    while context.error.result == KAI_SUCCESS {
        if _create_syntax_trees(*context, info.sources) break;
        if _generate_nodes(*context) break;
        if _compile_all_nodes_in_scope(*context) break;
        if !(info.options.flags & KAI_COMPILE_NO_CODE_GEN)
        {
            allocator: Allocator = info.allocator;
            machine_code: *void = allocator.platform_allocate(
                allocator.user, null, 0x10000, KAI_MEMORY_COMMAND_ALLOCATE_WRITE_ONLY);
            _memory_copy(machine_code, context.assembler.code.data, context.assembler.code.count*4);
            if context.debug_writer != null {
                printf("---Machine-Code---\n");
                for i: 0..<context.assembler.code.count {
                    instr: u32 = context.assembler.code.data[i];
                    printf("%02X%02X%02X%02X\n", (instr >> 0) & 0xFF, (instr >> 8) & 0xFF, (instr >> 16) & 0xFF, (instr >> 24) & 0xFF);
                    // printf("%08X\n", instr);
                }
                printf("------------------\n");
            }
            allocator.platform_allocate(
                allocator.user, machine_code, context.assembler.code.count*4, KAI_MEMORY_COMMAND_SET_EXECUTABLE);
            context.program.code.data = machine_code;
            context.program.code.count = context.assembler.code.count*4;
        }
        if context.debug_writer != null
        {
            for i: 0..<context.type_cache.capacity {
                if (context.type_cache.occupied[i/64] & (1->u64 << (i%64)))
                    _debug_show_type(*context, context.type_cache.keys[i]);
            }
        }
        break;
    }

    context.program.trees = context.trees;
    ret context.error.result;
}

destroy_program :: (program: *Program)
{
    program->void;
}

find_variable :: (program: *Program, name: string, out_type: *Type) -> *void
{
    index: int = table_find(*program.variable_table, name);
    if index == -1 ret null;
    var: Variable = program.variable_table.values[index];
    if out_type != null {
        [out_type] = var.type;
    }
    ret program.data.data + var.location;
}
//@doc_description (
//"""
//Returns a pointer to an exported variable in the script.
//Returning a pointer allows the host program to modify the variable at anytime
//after the script is compiled, and it is the host programmer's responsibility
//to handle things like race conditions.
//"""
//)
@doc_warning ("If you wish to modify the variable, then make sure the variable is not declared as a constant in the script!")

find_procedure :: (program: *Program, name: string, type: string) -> *void
{
    type->void; // TODO: use type for something?
    
    t: *Type_Info;
    ptr: *void = find_variable(program, name, *t);

    // Check variable is a procedure
    if t == null || t.id != KAI_TYPE_ID_PROCEDURE ret null;
    
    offset: u32 = [ptr -> *u32];
    ret program.code.data + offset;
}
