
Compile_Flags :: enum u32 {
    COMPILE_NO_CODE_GEN  =  0x0001; // "type-check" only
}

Compile_Options :: struct {
    Interpreter_Max_Step_Count : u32; // default = 1000000
    Interpreter_Max_Call_Depth : u32; // default = 1024
    flags : Compile_Flags;
}

Native_Procedure :: struct {
    name        : *u8;
    address     : *void;
    typestring  : string;
}

Named_Type :: struct {
	name: string;
	type: Type;
}

Program_Create_Info :: struct {
    sources           : [] Source;
    allocator         : Allocator;
    error             : *Error;
    native_procedures : [] Native_Procedure;
	builtin_types     : [] Named_Type; // maybe we should insert types ???
	options           : Compile_Options;
}

Program :: struct {
    code            : [] u8;
    procedure_table : [string] u32;
    variable_table  : [string] u32;
    type_table      : [string] Type;
    allocator       : Allocator;
}

Node_Flags :: enum u32 {
	NODE_TYPE            = 0x01;
	NODE_TYPE_EVALUATED  = 0x02;
	NODE_VALUE_EVALUATED = 0x04;
	NODE_EVALUATED       = 0x06;
	NODE_LOCAL           = 0x08;
	NODE_NOT_FOUND       = 0x80;
}

Node_Reference :: struct {
	flags: Node_Flags;
	index: u32;
}

Node_Value :: union {
	ptr:  *void;
	u64:  u64;
	s64:  s64;
	f64:  f64;
	type: Type;
}

// Nodes have two high level types: Variable or Procedure
// Nodes also live at Runtime or are Const
// Const nodes get baked into the program and do not live past compilation
//    while Runtime nodes can either be baked in (inlined) or hold a memory addess
// Only nodes that are explicitly marked with `#export` can be queried by the host program
Node :: struct {
	type:                    Type;       // evaluated type
	value:                   Node_Value; // evaluated value
	location:                Location;
	expr:                   *Expr;
	type_expr:              *Expr;
	value_dependencies: [..] Node_Reference;
	type_dependencies:  [..] Node_Reference; // This can be arena??????
	flags:                   Node_Flags;
}

Scope :: struct {
    identifiers: [string] Node_Reference;
    is_proc_scope: bool;
}

/* Sea of Nodes
IrTypeId :: enum u32 {
	BOT    = 0; // Bottom (ALL)
	TOP    = 1; // Top    (ANY)
	CTRL   = 2; // Ctrl flow bottom
	SIMPLE = 3; // End of the Simple Types
	NUMBER = 4; // All Numbers
	INT    = 4; // All Integers
	TUPLE  = 5; // Tuples; finite collections of unrelated Types, kept in parallel
}

IrTypeFlag :: enum u32 {
    CONST = 0x0001;
    TOP   = 0x0002;
}

IrValue :: union {
    number: Number;
    prim:   Value;
    tuple:  [..] IrType;
}

IrType :: struct {
    type:     IrTypeId;
    flags:    IrTypeFlag;
    value:    IrValue;
}

IrNode :: struct {
    id:       u32;
    inputs:   [..] *IrNode;
    outputs:  [..] *IrNode;
    type:     IrType;
}
*/

Compiler_Context :: struct {
    error:              *Error;
    allocator:           Allocator;
    program:            *Program;
	options:             Compile_Options;
    trees:               [] Syntax_Tree;
    scopes:              [..] Scope;
    nodes:               [..] Node;
    compilation_order:   [] u32;
    type_allocator:      Arena_Allocator;
    temp_allocator:      Arena_Allocator;
    current_source:      Source;
    current_node:        Node_Reference;
}

_create_syntax_trees :: (context: *Compiler_Context, sources: [] Source) -> bool
{
	allocator: *Allocator = *context.allocator;
	context.trees.data = _allocate(null, sources.count * sizeof(Syntax_Tree), 0) -> *Syntax_Tree;
	context.trees.count = sources.count;
	for i: 0..<sources.count {
		info: Syntax_Tree_Create_Info = Syntax_Tree_Create_Info.{
			source = sources[i],
			allocator = context.allocator,
			error = context.error,
		};
		if create_syntax_tree(*info, *array_last(*context.trees)) != KAI_SUCCESS
			ret true;
	}
	ret false;
}

_inside_procedure_scope :: (context: *Compiler_Context) -> bool
{
    for i: 0..<context.scopes.count {
        ri: u32 = context.scopes.count - 1 - i;
        scope: *Scope = *context.scopes.data[ri];
        if scope.is_proc_scope ret true;
    }
    ret false;
}

_error_redefinition :: (context: *Compiler_Context, location: Location, original: u32) -> bool
{
    /context.error = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };

    buffer: Buffer = Buffer.{allocator = context.allocator};

    // First error message	
    {
        _buffer_append_string(*buffer, STRING("indentifier \""));
        _buffer_append_string(*buffer, location.string); // 24
        _buffer_append_string(*buffer, STRING("\" has already been declared"));
        range: Range = _buffer_end(*buffer);
        context.error.memory = _buffer_done(*buffer);
        context.error.message = _range_to_string(range, context.error.memory);
    }

    // Extra info
    {
        // Append to memory
        info_range: Range = _buffer_push(*buffer, sizeof(Error));
        _buffer_append_string(*buffer, STRING("see original definition of \""));
        _buffer_append_string(*buffer, location.string); // 24
        _buffer_append_string(*buffer, STRING("\""));
        message_range: Range = _buffer_end(*buffer);
        memory: Memory = _buffer_done(*buffer);

        existing: *Node = *context.nodes.data[original];

        // Put everything together
        info: *Error = (memory.data->*u8 + info_range.start) -> *Error;
        /info = Error.{
            result = KAI_ERROR_INFO,
            location = existing.location,
            message = _range_to_string(message_range, memory),
            memory = memory,
        };
        context.error.next = info;
    }

    ret true;
}

_error_not_declared :: (context: *Compiler_Context, location: Location) -> bool
{
    /context.error = Error.{
        result = KAI_ERROR_SEMANTIC,
        location = location,
    };
    buffer: Buffer = Buffer.{allocator = context.allocator};
    _buffer_append_string(*buffer, STRING("indentifier \""));
    _buffer_append_string(*buffer, location.string);
    _buffer_append_string(*buffer, STRING("\" not declared"));
    range: Range = _buffer_end(*buffer);
    context.error.memory = _buffer_done(*buffer);
    context.error.message = _range_to_string(range, context.error.memory);
    ret true;
}

_create_nodes :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    allocator: *Allocator = *context.allocator;
    allocator->void;

    if expr.id == {
    case KAI_EXPR_PROCEDURE; {
        /*
        Kai_Expr_Procedure* node = base;

        Kai_u32 new_scope_index = Context->scopes.count;
        kai__array_append(&Context->scopes, (Kai__DG_Scope) {
            .parent = Scope_Index,
            .is_proc_scope = KAI_TRUE,
        });
        //kai__hash_table_create(&Context->scopes.elements[new_scope_index].identifiers);

        node->_scope = new_scope_index;
        if (node->body) {
            return kai__dg_create_nodes_from_statement(Context, node->body, new_scope_index, KAI_TRUE, KAI_TRUE);
        }
        else {
            kai__todo("Native Functions not implemented!");
        }
        */
    }
    case KAI_STMT_IF; {
        /*
        Kai_Stmt_If* node = base;

        result = kai__dg_create_nodes_from_statement(Context, node->then_body, Scope_Index, In_Procedure, KAI_FALSE);
        if (result != KAI_SUCCESS)
            return result;

        if (node->else_body) {
            result = kai__dg_create_nodes_from_statement(Context, node->else_body, Scope_Index, In_Procedure, KAI_FALSE);
            if (result != KAI_SUCCESS)
                return result;
        }
        */
    }
    case KAI_STMT_FOR; {
        /*
        Kai_Stmt_For* node = base;
        return kai__dg_create_nodes_from_statement(Context, node->body, Scope_Index, In_Procedure, KAI_FALSE);
        */
    }
    case KAI_STMT_DECLARATION; {
        d: *Stmt_Declaration = cast expr;

        // Skip non-constants
        if (!(d.flags & KAI_FLAG_DECL_CONST) && _inside_procedure_scope(context))
            ret false;

        location: Location = Location.{
            source = context.current_source,
            string = d.name,
            line = d.line_number,
        };

        scope: *Scope = *array_last(*context.scopes);

        // Does this declaration already exist for this Scope?
        {
            index: int = table_find(*scope.identifiers, d.name);
            if index != -1 {
                reference: Node_Reference = scope.identifiers.values[index];
                context.error.result = KAI_ERROR_FATAL;
                ret _error_redefinition(context, location, reference.index);
            }
        }

        {
            reference: Node_Reference = Node_Reference.{index = context.nodes.count};
            node: Node = Node.{location = location, expr = d.expr, type_expr = d.type};

            array_push(*node.value_dependencies, Node_Reference.{flags = KAI_NODE_TYPE, index = reference.index});
            array_push(*context.nodes, node);
            table_set(*scope.identifiers, d.name, reference);
        }

        if d.expr != null {
            ret _create_nodes(context, d.expr);
        }
        ret false;
    }
    case KAI_STMT_COMPOUND; {
        c: *Stmt_Compound = cast expr;
        array_push(*context.scopes, Scope.{0});
        current: *Stmt = c.head;
        while current {
            if _create_nodes(context, current)
                ret true;
            current = current.next;
        }
        array_pop(*context.scopes);
        ret false;
    }
    }
    ret false;
}

_lookup_node :: (context: *Compiler_Context, name: string) -> Node_Reference
{
    for i: 0..<context.scopes.count {
        ri: u32 = context.scopes.count - 1 - i;
        scope: *Scope = *context.scopes.data[ri];
        k: int = table_find(*scope.identifiers, name);
        if k == -1 continue;
        ret scope.identifiers.values[k];
    }

    ret Node_Reference.{flags = KAI_NODE_NOT_FOUND};
}

add_dependency :: (context: *Compiler_Context, ref: Node_Reference)
{
    allocator: *Allocator = *context.allocator;
    deps: *[..] Node_Reference;
    node: *Node = *context.nodes.data[context.current_node.index];

    if context.current_node.flags & KAI_NODE_TYPE
        deps = *node.type_dependencies;
    else
        deps = *node.value_dependencies;

    for i: 0..<deps.count {
        other: Node_Reference = deps.data[i];
        if ref.index == other.index && ref.flags == other.flags
            ret;
    }
    array_push(deps, ref);
}

_insert_value_dependencies :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    //allocator: *Allocator = *context.allocator;
    if expr == null { kai__todo("null expression\n"); }

    if expr.id == {
    case KAI_EXPR_IDENTIFIER; {
        ref: Node_Reference = _lookup_node(context, expr.source_code);

        if ref.flags & KAI_NODE_NOT_FOUND {
            node: *Node = *context.nodes.data[context.current_node.index];
            location: Location = Location.{source = node.location.source, string = expr.source_code, line = expr.line_number};
            ret _error_not_declared(context, location);
        }

        if ref.flags & KAI_NODE_LOCAL break;
        
        add_dependency(context, ref);
    }

    case KAI_EXPR_UNARY; {
        u: *Expr_Unary = cast expr;
        ret _insert_value_dependencies(context, u.expr);
    }

    case KAI_EXPR_BINARY; {
        b: *Expr_Binary = cast expr;
        if _insert_value_dependencies(context, b.left)
            ret true;
        if _insert_value_dependencies(context, b.right)
            ret true;
    }
/*
    case KAI_EXPR_PROCEDURE_CALL: {
        Kai_Expr_Procedure_Call* node = base;

        // Procedure calls in procedures are fine, we only need to know the type to generate the bytecode
        // TODO: possible bug for nested procedures
        if (In_Procedure) {
            result = kai__dg_insert_type_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->proc
            );
        }
        else {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->proc,
                In_Procedure
            );
        }
        if (result != KAI_SUCCESS)
            return result;

        Kai_Expr current = node->arg_head;
        while (current != NULL) {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                current,
                In_Procedure
            );
            if (result != KAI_SUCCESS)
                return result;
            current = current->next;
        }
    }
    case KAI_EXPR_PROCEDURE; {
        Kai_Expr_Procedure* node = base;
        Kai__DG_Scope* local_scope = Context->scopes.elements + node->_scope;

        // Insert procedure input names to local scope
        Kai_Expr current = node->in_out_expr;
        for (int i = 0; i < (int)node->in_count; ++i) {
            Kai__DG_Node_Index* node_index = kai__hash_table_find(local_scope->identifiers, current->name);
            
            if (node_index != NULL) {
                Kai__DG_Node* original = &Context->nodes.elements[node_index->value];
                return kai__error_redefinition(
                    Context->error,
                    allocator,
                    current->name,
                    current->line_number,
                    original->name,
                    original->line_number
                );
            }

            kai__hash_table_emplace(local_scope->identifiers, current->name, (Kai__DG_Node_Index) {
                .flags = KAI__DG_NODE_LOCAL_VARIABLE,
            });

            current = current->next;
        }

        if (node->body) {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                node->_scope,
                node->body,
                KAI_TRUE
            );
        }

        kai__remove_local_variables(local_scope);
    } break;
    break; case KAI_STMT_DECLARATION: {
        if (In_Procedure) {
            Kai_Stmt_Declaration* node = base;
            // Already has a dependency node
            if (node->flags & KAI_DECL_FLAG_CONST)
                return KAI_SUCCESS;
            Kai__DG_Scope* scope = Context->scopes.elements + Scope_Index;
            // Insert into local scope (if not already defined)
            Kai__DG_Node_Index* node_index = kai__hash_table_find(scope->identifiers, node->name);
            if (node_index != NULL && node_index->flags != KAI__DG_NODE_LOCAL_VARIABLE) {
                Kai__DG_Node* original = &Context->nodes.elements[node_index->value];
                return kai__error_redefinition(
                    Context->error,
                    allocator,
                    node->name,
                    node->line_number,
                    original->name,
                    original->line_number
                );
            }

            kai__hash_table_emplace(scope->identifiers,
                node->name,
                (Kai__DG_Node_Index) {
                    .flags = KAI__DG_NODE_LOCAL_VARIABLE,
                }
            );

            // Look into it's definition to find possible dependencies
            return kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->expr,
                KAI_TRUE
            );
        }
        else kai__todo("invalid declaration\n");
    }

    break; case KAI_STMT_ASSIGNMENT: {
        if (In_Procedure) {
            Kai_Stmt_Assignment* node = base;
            return kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->expr,
                KAI_TRUE
            );
        }
        else kai__todo("invalid assignment\n");
    }

    case KAI_STMT_RETURN: {
        Kai_Stmt_Return* node = base;
        if (In_Procedure) {
            return kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->expr,
                KAI_TRUE
            );
        }
        else kai__todo("invalid return\n");
    } break;

    break; case KAI_STMT_IF: {
        Kai_Stmt_If* node = base;
        result = kai__dg_insert_value_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->then_body,
            In_Procedure
        );
        if (result != KAI_SUCCESS)
            return result;
        if (node->else_body != NULL) {
            return kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                node->else_body,
                In_Procedure
            );
        }
    }

    break; case KAI_STMT_COMPOUND: {
        if (In_Procedure) {
            Kai_Stmt_Compound* node = base;
            Kai_Expr current = node->head;
            while (current != NULL) {
                result = kai__dg_insert_value_dependencies(
                    Context,
                    out_Dependency_Array,
                    node->_scope,
                    current,
                    KAI_TRUE
                );
                if (result != KAI_SUCCESS)
                    return result;
                current = current->next;
            }
            Kai__DG_Scope* scope = Context->scopes.elements + node->_scope;
            kai__remove_local_variables(scope);
        }
        else kai__todo("invalid compound statement\n");
    }

    break; case KAI_STMT_FOR: {
        Kai_Stmt_For* node = base;
        return kai__dg_insert_value_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->body,
            In_Procedure
        );
    }
*/
    }

    ret false;
}
_insert_type_dependencies :: (context: *Compiler_Context, expr: *Expr) -> bool
{
    if expr == null { kai__todo("null expression\n"); }

    if expr.id == {
    case KAI_EXPR_IDENTIFIER; {
        ref: Node_Reference = _lookup_node(context, expr.source_code);

        if ref.flags & KAI_NODE_NOT_FOUND {
            node: *Node = *context.nodes.data[context.current_node.index];
            location: Location = Location.{source = node.location.source, string = expr.source_code, line = expr.line_number};
            ret _error_not_declared(context, location);
        }

        if ref.flags & KAI_NODE_LOCAL break;
        
        ref.flags |= KAI_NODE_TYPE;
        add_dependency(context, ref);
    }

    case KAI_EXPR_UNARY; {
        u: *Expr_Unary = cast expr;
        ret _insert_type_dependencies(context, u.expr);
    }

    case KAI_EXPR_BINARY; {
        b: *Expr_Binary = cast expr;
        if _insert_type_dependencies(context, b.left)
            ret true;
        if _insert_type_dependencies(context, b.right)
            ret true;
    }
/*
    break; case KAI_EXPR_PROCEDURE_CALL: {
        Kai_Expr_Procedure_Call* node = base;

        result = kai__dg_insert_type_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->proc
        );
        if (result != KAI_SUCCESS)
            return result;

        Kai_Expr current = node->arg_head;
        while (current != NULL) {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                current,
                KAI_FALSE // TODO: possible bug here ??
            );
            if (result != KAI_SUCCESS)
                return result;
            current = current->next;
        }
    }

    break; case KAI_EXPR_PROCEDURE_TYPE: {
        //kai__todo("procedure type\n");
    }

    break; case KAI_EXPR_PROCEDURE: {
        Kai_Expr_Procedure* node = base;
        Kai_Expr current = node->in_out_expr;
        while (current != NULL) {
            result = kai__dg_insert_value_dependencies(
                Context,
                out_Dependency_Array,
                Scope_Index,
                current,
                KAI_FALSE // TODO: possible bug here ??
            );
            if (result != KAI_SUCCESS)
                return result;
            current = current->next;
        }
    }

    break; case KAI_STMT_DECLARATION: {
        // What do we do here exactly?
        kai__todo("declaration\n");
    }

    break; case KAI_STMT_RETURN: {
        Kai_Stmt_Return* node = base;
        return kai__dg_insert_type_dependencies(
            Context,
            out_Dependency_Array,
            Scope_Index,
            node->expr
        );
    }

    break; case KAI_STMT_COMPOUND: {
        kai__todo("compound\n");
    }
*/
    }
    
    ret false;
}

_generate_dependency_builtin_types :: (context: *Compiler_Context) -> bool
{
	allocator: *Allocator = *context.allocator;
	scope: *Scope = *array_last(*context.scopes);
	ref: Node_Reference;

	type_type: *Type_Info = cast arena_allocate(*context.type_allocator, sizeof(Type_Info));
	type_type.id = KAI_TYPE_ID_TYPE;
	ref.index = context.nodes.count;
	table_set(*scope.identifiers, STRING("Type"), ref);
	array_push(*context.nodes, Node.{type = type_type, value = Node_Value.{type = type_type}, flags = KAI_NODE_EVALUATED});
	
	s32_type: *Type_Info_Integer = cast arena_allocate(*context.type_allocator, sizeof(Type_Info_Integer));
	s32_type.id = KAI_TYPE_ID_INTEGER;
	s32_type.is_signed = true;
	s32_type.bits = 32;
	ref.index = context.nodes.count;
	table_set(*scope.identifiers, STRING("s32"), ref);
	array_push(*context.nodes, Node.{type = type_type, value = Node_Value.{type = s32_type->Type}, flags = KAI_NODE_EVALUATED});
	
	ret false;
}

_generate_dependency_graph :: (context: *Compiler_Context) -> bool
{
    allocator: *Allocator = *context.allocator;
    allocator->void;
    
    // Initialize Global Scope
    array_push(*context.scopes, Scope.{ is_proc_scope = false });

	if _generate_dependency_builtin_types(context)
		ret true;

    // Insert nodes from syntax tree
    for i: 0..<context.trees.count {
        tree: *Syntax_Tree = *context.trees.data[i];
        context.current_source = tree.source;

        current: *Stmt = tree.root.head;
        while current {
            if _create_nodes(context, current)
                ret true;
            current = current.next;
        }
    }

    // Insert dependencies for each node
    for i: 0..<context.nodes.count
    {
        node: *Node = *context.nodes.data[i];
        context.current_node.index = i;

		if node.flags & KAI_NODE_EVALUATED
			continue;

        context.current_node.flags = 0;
        if _insert_value_dependencies(context, node.expr)
            ret true;

        context.current_node.flags = KAI_NODE_TYPE;
        if _insert_type_dependencies(context, node.expr)
            ret true;
    }
/*
    for i: 0..<context.nodes.count {
        node: *Node = *context.nodes.data[i];
        printf("node (%i) %.*s V{ ", i, node.location.string.count, node.location.string.data);
        for j: 0..<node.value_dependencies.count {
            ref: Node_Reference = node.value_dependencies.data[j];
            id: u8 = #char "v";
            if ref.flags & KAI_NODE_TYPE id = #char "t";
            printf("%i%c", ref.index, id);
            if j+1 < node.value_dependencies.count
                printf(", ");
        }
        printf(" } T{ ");
        for j: 0..<node.type_dependencies.count {
            ref: Node_Reference = node.type_dependencies.data[j];
            id: u8 = #char "v";
            if ref.flags & KAI_NODE_TYPE id = #char "t";
            printf("%i%c", ref.index, id);
            if j+1 < node.type_dependencies.count
                printf(", ");
        }
        printf(" }\n");
    }
*/
    ret false;
}

_DFS_Context :: struct {
    context: *Compiler_Context;
    post: *u32;
    prev: *u32;
    visited: *bool;
    next: u32;
}

_explore_dependencies :: (dfs: *_DFS_Context, ref: Node_Reference)
{
    index: u32 = (ref.index << 1) | (ref.flags & KAI_NODE_TYPE);
    dfs.visited[index] = true;

    node: *Node = *dfs.context.nodes.data[ref.index];

    deps: *[..] Node_Reference;
    if ref.flags & KAI_NODE_TYPE  deps = *node.type_dependencies;
    else                          deps = *node.value_dependencies;

    for d: 0..<deps.count {
        dep: Node_Reference = deps.data[d];
        d_index: u32 = (dep.index << 1) | (dep.flags & KAI_NODE_TYPE);

        if !dfs.visited[d_index] {
            dfs.prev[d_index] = index;
            _explore_dependencies(dfs, dep);
        }
    }

    dfs.post[index] = dfs.next;
    dfs.next += 1;
}

_generate_compilation_order :: (context: *Compiler_Context) -> bool
{
    // TODO: only one allocation necessary
    allocator: *Allocator = *context.allocator;
    dfs: _DFS_Context = _DFS_Context.{context = context, next = 0};
    dfs.post    = _allocate(null, context.nodes.count * 2 * sizeof(u32), 0) -> *u32;
    dfs.prev    = _allocate(null, context.nodes.count * 2 * sizeof(u32), 0) -> *u32;
    dfs.visited = _allocate(null, context.nodes.count * 2 * sizeof(bool), 0) -> *bool;
    _memory_fill(dfs.prev, 0xFF, context.nodes.count * 2 * sizeof(u32));

    // Perform DFS traversal
    for i: 0..<context.nodes.count {
        ref: Node_Reference = Node_Reference.{index = i};

        v: u32 = (ref.index << 1) | (ref.flags & KAI_NODE_TYPE);
        if !dfs.visited[v] _explore_dependencies(*dfs, ref);

        ref.flags = KAI_NODE_TYPE;
        t: u32 = (ref.index << 1) | (ref.flags & KAI_NODE_TYPE);
        if !dfs.visited[t] _explore_dependencies(*dfs, ref);
    }

    // Sort based on the post number to linearize the graph
    context.compilation_order.count = context.nodes.count * 2;
    context.compilation_order.data = _allocate(null, context.compilation_order.count * sizeof(u32), 0) -> *u32;

    for i: 0..<context.compilation_order.count {
        context.compilation_order.data[dfs.post[i]] = i;
    }
/*
    for i: 0..<context.compilation_order.count {
        k: u32 = context.compilation_order.data[i];
        index: u32 = k >> 1;
        ch: u8 = #char "v";
        if k & 1 { ch = #char "t"; }
        printf("%i%c\n", index, ch);
    }
*/
    ret false;
}

_error_fatal :: (context: *Compiler_Context, message: string) -> bool
{
	context.error.result = KAI_ERROR_FATAL;
	context.error.message = message;
	ret true;
}

_value_of_expression :: (context: *Compiler_Context, expr: *Expr, type: *Type) -> Node_Value
{
	assert(expr != null);

	if expr.id == {
		case KAI_EXPR_IDENTIFIER; {
			ref: Node_Reference = _lookup_node(context, expr.source_code);

			if ref.flags & KAI_NODE_NOT_FOUND {
				_error_fatal(context, STRING("cant find node [todo]"));
				ret Node_Value.{};
			}

			node: *Node = *context.nodes.data[ref.index];
			
			if !(node.flags & KAI_NODE_EVALUATED) {
				_error_fatal(context, STRING("node not evaluated [todo]"));
				ret Node_Value.{};
			}

			/type = node.type;
			ret node.value;
		}

		case; {
			kai__todo("%s (expr.id = %i)", __FUNCTION__, expr.id);
		}
	}
}

_type_of_expression :: (context: *Compiler_Context, expr: *Expr) -> Type
{
	context->void;
	expr->void;
	printf("what is type?\n");
	ret null;
}

_compile_node_value :: (context: *Compiler_Context, node: *Node) -> bool
{
	context->void;
	node->void;
	printf("value is too hard :(((\n");
	ret true;
}

_compile_node_type :: (context: *Compiler_Context, node: *Node) -> bool
{
	if node.type_expr != null {
		type: *Type_Info;
		value: Node_Value = _value_of_expression(context, node.type_expr, *type);
		
		if type == null
			ret true;
		if type.id != KAI_TYPE_ID_TYPE
			ret _error_fatal(context, STRING("type is not type"));
		
		node.type = value.type;
		node.flags |= KAI_NODE_TYPE_EVALUATED;
		ret false;
	}

	type: Type = _type_of_expression(context, node.expr);
	if type == null
		ret true;

	node.type = type;
	node.flags |= KAI_NODE_TYPE_EVALUATED;
	ret false;
}

_generate_code_no_code_gen :: (context: *Compiler_Context) -> bool
{
    for i: 0..<context.compilation_order.count {
        k: u32 = context.compilation_order.data[i];
        ref: Node_Reference = Node_Reference.{index = (k >> 1), flags = (k & 1)};
		node: *Node = *context.nodes.data[ref.index];

		if node.flags & KAI_NODE_EVALUATED
			continue;

		if ref.flags & KAI_NODE_TYPE {
			if _compile_node_type(context, node)
				ret true;
		}
		else {
			if _compile_node_value(context, node)
				ret true;
		}
    }
    ret false;
}

_generate_compiler_ir :: (context: *Compiler_Context) -> bool
{
    context->void;
    //context.error.result = KAI_ERROR_FATAL;
    ret false;
}

create_program :: (info: *Program_Create_Info, out_program: *Program) -> Result
{
    context: Compiler_Context = Compiler_Context.{
        error = info.error,
        allocator = info.allocator,
        program = out_program,
        options = info.options,
    };
	arena_create(*context.type_allocator, *info.allocator);

	if !(info.options.flags & KAI_COMPILE_NO_CODE_GEN) {
		context.error.message = STRING("Code generation not currently supported :(");
		context.error.result = KAI_ERROR_FATAL;
		ret KAI_ERROR_FATAL;
	}

    while context.error.result == KAI_SUCCESS {
        if _create_syntax_trees(*context, info.sources) break;
        if _generate_dependency_graph(*context) break;
        if _generate_compilation_order(*context) break;
        if _generate_code_no_code_gen(*context) break;
        break;
    }

    ret context.error.result;
}

destroy_program :: (program: *Program)
{
    program->void;
}

Variable :: struct {
    data: *void;
    type: Type;
}

find_variable :: (program: *Program, name: string) -> Variable
{
    //table_find(program);
    program->void;
    name->void;
    ret Variable.{0};
}

find_procedure :: (program: *Program, name: string, opt_type: Type) -> *void
{
    program->void;
    name->void;
    opt_type->void;
    ret null;
}
