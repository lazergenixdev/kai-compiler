// lang :: #import "common_language_semantics"

VERSION_STRING :: #host_import;
VERSION_MAJOR  :: #host_import;
VERSION_MINOR  :: #host_import;
VERSION_PATCH  :: #host_import;

#export version_string :: () -> string
{
    ret VERSION_STRING;
}
@doc_short ("Get version as string (includes extra version info)")

#export version :: () -> [3] u32
{
    ret {VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH};
}
@doc_short ("Get version as number")

// Math

ldexp :: #host_import;

ceil_div :: (num: u64, den: u64) -> u64
{
    ret (num + den - 1) / den;
}

ceil_div_fast :: (num: u64, exp: u32) -> u64
{
    ret (num + (1 << exp) - 1) >> exp;
}

max_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret b;
    ret a;
}

min_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret a;
    ret b;
}

gcd :: (a: u64, b: u64) -> u64
{
    r: u64 = 1;
    while r != 0 {
        r = a % b;
        b = r;
        a = b;
    }
    ret r;
}

// TODO: rename, need module system ðŸ˜­
/*mul_with_shift :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    prod := builtin.u128_multiply(a, b);
    
    if prod.high == 0 {
        // Fits in 64 bits, no shift needed
        ret prod.low;
    }
    
    // Amount of right shift required to fit in 64 bits
    shift := 64 - intrinsics.count_leading_zeros(prod.high);
    
    if sub then [exp] -= shift;
    else        [exp] += shift;
    ret (prod.high << (64 - shift)) | (prod.low >> shift);
}*/

add_with_shift :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    sum := a + b;
    carry := sum < a;
    if !carry ret sum;
    if sub then [exp] -= 1;
    else        [exp] += 1;
    ret (1 << 63) | (sum >> 1);
}

// Memory Allocator

#export Memory_Command :: enum u32 {
    ALLOCATE_WRITE_ONLY :: 0;
    SET_EXECUTABLE      :: 1;
    FREE                :: 2;
};

#export Memory_Heap_Allocate     :: #proc (user: *void, ptr: *void, new_size: u32, old_size: u32) -> *void;
#export Memory_Platform_Allocate :: #proc (user: *void, ptr: *void, size: u32, op: Memory_Command) -> *void;

Allocator :: struct {
    heap_allocate      : Memory_Heap_Allocate;
    platform_allocate  : Memory_Platform_Allocate;
    user               : *void;
    page_size          : u32;
}

// General Memory Operations

memory_copy :: (dst: *void, src: *void, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = (src->*u8)[i];
    }
}
memory_zero :: (dst: *void, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = 0;
    }
}
memory_fill :: (dst: *void, byte: u8, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = byte;
    }
}

// String Operations

#export string_equals :: (left: string, right: string) -> bool
{
    if left.count != right.count
        ret false;
    for i: 0..<left.count {
        if left.data[i] != right.data[i]
            ret false;
    }
    ret true;
}

#export string_from_c :: (s: *s8 @const) -> string
{
    count: u32;
    while s[count] != 0
        count += 1;
    ret {count = count, data = s->*u8};
}

#export string_from_data :: (data: *u8, count: u32) -> string
{
    ret {count = count, data = data};
}

// http://www.cse.yorku.ca/~oz/hash.html (djb2)
// " this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c.
// " another version of this algorithm (now favored by bernstein) uses xor:
// " hash(i) = hash(i - 1) * 33 ^ str[i]; the magic of number 33
// " (why it works better than many other constants, prime or not) has never been adequately explained. 

string_hash :: (s: string) -> u64
{
    hash: u64 = 5381;
    for i: 0..<s.count
        hash = ((hash << 5) + hash) + s.data[i]->u64; // hash * 33 + c
    ret hash;
}

string_hash_next :: (hash: u64, s: string) -> u64
{
    for i: 0..<s.count
        hash = ((hash << 5) + hash) + s.data[i]->u64;
    ret hash;
}

// Dynamic Arrays

#export Raw_Dynamic_Array :: struct {
    count    : u32;
    capacity : u32;
    data     : *void;
}

#export raw_array_reserve :: (array: *Raw_Dynamic_Array, allocator: *Allocator, new_capacity: u32, elem_size: u32)
{    
    if new_capacity <= array.capacity ret;
    //(array.data, new_capacity * elem_size, array.capacity * elem_size);
    //array.data = allocator.heap_allocate(allocator.user, 0, 0, 0);
    array.capacity = new_capacity;
}

// Hash Table

Raw_Hash_Table :: struct {
    count    : u32;
    capacity : u32;
    occupied : *u64;
    hashes   : *u64;
    keys     : *string;
    values   : *void;
}

Hash_Table_Size :: struct {
    occupied : u32;
    hashes   : u32;
    keys     : u32;
    values   : u32;
    total    : u32;
}
/*
// Calculate size required for hash table
raw_hash_table_size :: (capacity: u32, elem_size: u32) -> Hash_Table_Size
{
    r: Hash_Table_Size;
    r.occupied = ceil_div_fast(capacity->u64, 6)->u32;// * #size(u64);
    r.hashes   = capacity;// * #size(u64);
    r.keys     = capacity;// * #size(string);
    r.values   = (capacity + 1) * elem_size;
    r.total    = r.occupied + r.hashes + r.keys + r.values;
    ret r;
}
*/
#export Type_Info :: struct {
    id : Type_Id;
}

// Errors

#export Result :: enum u32 {
    SUCCESS        :: 0;
    ERROR_MEMORY   :: 1;
    ERROR_SYNTAX   :: 2; @comment ("error from parsing")
    ERROR_TYPE     :: 3; @comment ("error from type checking")
    ERROR_SEMANTIC :: 3;
    ERROR_INFO     :: 4;
    ERROR_FATAL    :: 5; @comment ("means compiler bug probably")
    ERROR_INTERNAL :: 6; @comment ("means compiler error unrelated to the source code")
    RESULT_COUNT   :: 7;
}

#export Source :: struct {
    name:     string;
    contents: string;
}

#export Location :: struct {
    source : Source; // source code for this file
    string : string;
    line   : u32;
}

#export Error :: struct {
    result   : Result;
    location : Location;
    message  : string;
    context  : string;
    next     : *Error;
}

// Type Info

#export Type_Id :: enum u8 {
    TYPE      :: 0; @comment ("no type info struct")
    VOID      :: 1; @comment ("no type info struct")
    BOOLEAN   :: 2; @comment ("no type info struct")
    INTEGER   :: 3;
    FLOAT     :: 4;
    POINTER   :: 5;
    PROCEDURE :: 6;
    ARRAY     :: 7;
    STRUCT    :: 8;
    ENUM      :: 9;
    STRING    :: 10; @comment ("same as STRUCT")
    NUMBER    :: 11; @comment ("compiler internal only")
} @long_names

#export Type :: *Type_Info;


// Numbers

Number :: struct {
    n: u64;
    d: u64; @comment ("never 0 (except when n == 0)")
    e: s32;
    is_neg: bool;
}
@doc_short ("Number type used for number literals")

number_to_u64 :: (number: Number) -> u64
{
    ret number.n << number.e;
}
@doc_warning ("number must be normalized")

number_to_f64 :: (number: Number) -> f64
{
    if number.n == 0 ret 0.0;
    val := number.n->f64 / number.d->f64;
    if number.is_neg then
        val = -val;
    ret ldexp(val, number.e);
}
