// #import "builtin";
// lang :: #import "common_language_semantics"
//#import "new-allocator.kai";

//#import "builtin";

//#import "module:writer";
//#import "module:allocator";

VERSION_STRING :: #host_import;
VERSION_MAJOR  :: #host_import;
VERSION_MINOR  :: #host_import;
VERSION_PATCH  :: #host_import;

#export version_string :: () -> string
{
    ret VERSION_STRING;
}
@doc_short ("Get version as string (includes extra version info)")

#export version :: () -> [3] u32
{
    ret {VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH};
}
@doc_short ("Get version as number (x.y.z)")

// Math

ldexp :: #host_import;

ceil_div :: (num: u64, den: u64) -> u64
{
    ret (num + den - 1) / den;
}

ceil_div_fast :: (num: u64, exp: u32) -> u64
{
    ret (num + (1 << exp) - 1) >> exp;
}

max_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret b;
    ret a;
}

min_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret a;
    ret b;
}

gcd :: (a: u64, b: u64) -> u64
{
    r: u64 = 1;
    while r != 0 {
        r = a % b;
        b = r;
        a = b;
    }
    ret r;
}

Module_Mask :: enum u32 {
    BUILTIN = 1 << 0, // clz, ctz, popcount
    DEBUG   = 1 << 1, // print(...), breakpoint();
    STRINGS = 1 << 2, // concat, join, trim
}

//u128 :: struct { low: u64; high: u64; };
//Builtin :: struct {
//    u128_multiply : (a: u64, b: u64) -> u128;
//    count_leading_zeros : (a: u64) -> u32;
//}
//builtin: Builtin;

// TODO: rename + need module system ðŸ˜­
/*multiply_with_precision_loss :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    prod := builtin.u128_multiply(a, b);
    
    if prod.high == 0 {
        // Fits in 64 bits, no shift needed
        ret prod.low;
    }
    
    // Amount of right shift required to fit in 64 bits
    shift := 64 - builtin.count_leading_zeros(prod.high)->s32;
    
    if sub then [exp] -= shift;
    else        [exp] += shift;
    ret (prod.high << (64 - shift)) | (prod.low >> shift);
}*/

add_with_precision_loss :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    sum := a + b;
    carry := sum < a;
    if !carry ret sum;
    if sub then [exp] -= 1;
    else        [exp] += 1;
    ret (1 << 63) | (sum >> 1);
}

// Memory Allocator

#export Memory_Command :: enum u32 {
    ALLOCATE_WRITE_ONLY = 0,
    SET_EXECUTABLE      = 1,
    FREE                = 2,
};

#export Memory_Heap_Allocate     :: #proc (user: *void, ptr: *void, new_size: u32, old_size: u32) -> *void;
#export Memory_Platform_Allocate :: #proc (user: *void, ptr: *void, size: u32, op: Memory_Command) -> *void;

Allocator :: struct {
    heap_allocate      : Memory_Heap_Allocate;
    platform_allocate  : Memory_Platform_Allocate;
    user               : *void;
    page_size          : u32;
}

// General Memory Operations

memory_copy :: (dst: *void, src: *void, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = (src->*u8)[i];
    }
}
memory_copy_reverse :: (dst: *void, src: *void, size: u32)
{
    for i: 0..<size {
        r := size - i - 1;
        (dst->*u8)[r] = (src->*u8)[r];
    }
}
memory_zero :: (dst: *void, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = 0;
    }
}
memory_fill :: (dst: *void, byte: u8, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = byte;
    }
}

// String Operations

#export string_equals :: (left: string, right: string) -> bool
{
    if left.count != right.count
        ret false;
    for i: 0..<left.count
        if left.data[i] != right.data[i]
            ret false;
    ret true;
}

#export string_from_c :: (s: *s8 @const) -> string
{
    count: u32;
    while s[count] != 0
        count += 1;
    ret {count = count, data = s->*u8};
}

#export string_from_data :: (data: *u8, count: u32) -> string
{
    ret {count = count, data = data};
}

// http://www.cse.yorku.ca/~oz/hash.html (djb2)
// " this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c.
// " another version of this algorithm (now favored by bernstein) uses xor:
// " hash(i) = hash(i - 1) * 33 ^ str[i]; the magic of number 33
// " (why it works better than many other constants, prime or not) has never been adequately explained. 

hash_string :: (s: string) -> u64
{
    hash: u64 = 5381;
    for i: 0..<s.count
        hash = ((hash << 5) + hash) + s.data[i]->u64; // hash * 33 + c
    ret hash;
}

string_hash_next :: (hash: u64, s: string) -> u64
{
    for i: 0..<s.count
        hash = ((hash << 5) + hash) + s.data[i]->u64;
    ret hash;
}

// Dynamic Arrays

#export Raw_Dynamic_Array :: struct {
    count    : u32;
    capacity : u32;
    data     : *void;
}

#export raw_array_reserve :: (array: *Raw_Dynamic_Array, new_capacity: u32, allocator: *Allocator, elem_size: u32)
{    
    if new_capacity <= array.capacity ret;
    array.data = allocator.heap_allocate(allocator.user,
        array.data, new_capacity * elem_size, array.capacity * elem_size
    );
    array.capacity = new_capacity;
}

#export raw_array_resize :: (array: *Raw_Dynamic_Array, new_size: u32, allocator: *Allocator, elem_size: u32)
{    
    raw_array_reserve(array, new_size, allocator, elem_size);
    array.count = new_size;
}

#export raw_array_grow :: (array: *Raw_Dynamic_Array, count: u32, allocator: *Allocator, elem_size: u32)
{    
    if (array.count + count) <= array.capacity ret;
    n: u32 = array.count + count;
    new_capacity: u32 = max_u32(n + n/2, 8);
    raw_array_reserve(array, new_capacity, allocator, elem_size);
}

#export raw_array_remove :: (array: *Raw_Dynamic_Array, index: u32, elem_size: u32)
{
    // Pointer types should add/sub with any integral type (u8, u16, s32, ...)
    //dst := array.data->*u8 + index * elem_size;
    //remaining_count := array.count - index - 1;
    //memory_copy(dst, dst + elem_size, remaining_count * elem_size);
    array.count -= 1;
}

// Hash Table

Raw_Table_With_Key :: struct {
    count  : u32;
    keys   : *string;
    values : *void;
}

raw_table_find_string :: (table: *Raw_Table_With_Key, key: string, out_index: *u32) -> bool
{
    ret false;
}

// Errors

#export Result :: enum u32 {
    SUCCESS        = 0,
    ERROR_MEMORY   = 1,
    ERROR_SYNTAX   = 2, @comment ("error from parsing")
    ERROR_TYPE     = 3, @comment ("error from type checking")
    ERROR_SEMANTIC = 3,
    ERROR_INFO     = 4,
    ERROR_FATAL    = 5, @comment ("means compiler bug probably")
    ERROR_INTERNAL = 6, @comment ("means compiler error unrelated to the source code")
    RESULT_COUNT   = 7,
}

#export Source :: struct {
    name:     string;
    contents: string;
}

#export Location :: struct {
    source : Source; // source code for this file
    string : string;
    line   : u32;
}

#export Error :: struct {
    result   : Result;
    location : Location;
    message  : string;
    context  : string;
    next     : *Error;
}

// Type Info

#export Type_Id :: enum u8 {
    TYPE      = 0, @comment ("no type info struct")
    VOID      = 1, @comment ("no type info struct")
    BOOLEAN   = 2, @comment ("no type info struct")
    INTEGER   = 3,
    FLOAT     = 4,
    POINTER   = 5,
    PROCEDURE = 6,
    ARRAY     = 7,
    STRUCT    = 8,
    ENUM      = 9,
    STRING    = 10, @comment ("same as STRUCT")
    NUMBER    = 11, @comment ("compiler internal only")
} @long_names

#export Type :: *Type_Info;

#export Type_Info :: struct {
    id : Type_Id;
}

#export Type_Info_Integer :: struct {
    //using Type_Info;
    is_signed : bool;
    bits : u8;
}

// Numbers

Number :: struct {
    n: u64;
    d: u64; @comment ("never 0 (except when n == 0)")
    e: s32;
    is_neg: bool;
}
@doc_short ("Number type used for number literals")

number_to_u64 :: (number: Number) -> u64
{
    ret number.n << number.e;
}
@doc_warning ("number must be normalized")

number_to_f64 :: (number: Number) -> f64
{
    if number.n == 0 ret 0.0;
    val := number.n->f64 / number.d->f64;
    if number.is_neg then
        val = -val;
    ret ldexp(val, number.e);
}
/*/*
number_normalize :: (number: Number) -> Number
{
    if number.n == 0 ret Number.{};
    ns: s32 = intrinsics_ctz64(number.n);
    ds: s32 = intrinsics_ctz64(number.d);
    ex: s32 = number.e + (ns - ds);
    nu: u64 = number.n >> ns;
    de: u64 = number.d >> ds;
    cd: u64 = _gcd(nu, de);
    ret Number.{
        n = nu / cd,
        d = de / cd,
        e = ex,
        is_neg = number.is_neg,
    };
}
*/
number_neg :: (a: Number) -> Number
{
    ret {n = a.n, d = a.d, e = a.e, is_neg = a.is_neg ^ 1};
}

number_abs :: (a: Number) -> Number
{
    ret {n = a.n, d = a.d, e = a.e, is_neg = 0};
}

number_inv :: (a: Number) -> Number
{
    ret {n = a.d, d = a.n, e = -a.e, is_neg = a.is_neg};
}

number_add :: (a: Number, b: Number) -> Number
{
    /*
    if a.n == 0 ret b;
    if b.n == 0 ret a;

    if a.e == b.e
        ret number_add_same_exp(a, b);

    number_match_exponents(*a, *b);
    ret number_add_same_exp(a, b);
    */
}

number_sub :: (a: Number, b: Number) -> Number
{
    ret number_add(a, number_neg(b));
}

// ...

number_add_same_exp :: (a: Number, b: Number) -> Number
{
    /*
    t0e: s32 = 0;
    t1e: s32 = 0;
    t0: u64 = multiply_with_precision_loss(a.n, b.d, *t0e, 0);
    t1: u64 = multiply_with_precision_loss(b.n, a.d, *t1e, 0);
    ex: s32 = a.e;

    // Exponents have changed, need to make them the same again
    if t0e != t1e {
        if (t0e < t1e) {
            t0 = t0 >> (t1e - t0e);
            ex += t1e;
        }
        else {
            t1 = t1 >> (t0e - t1e);
            ex += t0e;
        }
    }

    de: u64 = multiply_with_precision_loss(a.d, b.d, *ex, 1);
    nu: u64;

    // Handle resulting sign
    is_neg: u32 = a.is_neg & b.is_neg;
    if a.is_neg && !b.is_neg {
        if t0 > t1 { nu = t0 - t1; is_neg = 1; } // -5 + 1
        else       { nu = t1 - t0; is_neg = 0; } // -1 + 5
    }
    else if b.is_neg && !a.is_neg {
        if t0 > t1 { nu = t0 - t1; is_neg = 0; } // 5 + -1
        else       { nu = t1 - t0; is_neg = 1; } // 1 + -5
    }
    else {
        nu = add_with_shift(t0, t1, *ex, 0);
    }

    ret number_normalize(Number.{
        n = nu, d = de, e = ex,
        is_neg = is_neg,
    });
    */
}

number_match_exponents :: (a: *Number, b: *Number)
{
    /*
    if a.e < b.e {
        // reduce b.e or increase a.e
        while a.e != b.e && (a.d >> 63) == 0 {
            a.d = a.d << 1;
            a.e += 1;
        }
        while a.e != b.e && (b.n >> 63) == 0 {
            b.n = b.n << 1;
            b.e -= 1;
        }
        // must lose some precision now :(
        diff: s64 = b.e - a.e;
        a.n = a.n >> diff->u32;
        a.e = b.e;
    }
    else /* a.e > b.e */ {
        // reduce a.e or increase b.e
        while (a.e != b.e && (b.d >> 63) == 0) {
            b.d = b.d << 1;
            b.e += 1;
        }
        while (a.e != b.e && (a.n >> 63) == 0) {
            a.n = a.n << 1;
            a.e -= 1;
        }
        // must lose some precision now :(
        diff: s64 = a.e - b.e;
        b.n = b.n >> diff->u32;
        b.e = a.e;
    }
    */
}
*/

/*
write_number :: (writer: *Writer, number: Number)
{
    // If number is a fraction, write it out as a float
    if !number_is_integer(number) {
        write_f64(number_to_f64(number));
        ret;
    }

    if number.is_neg {
        write("-");
    }

    // If number fits into u64, write it out as u64
    if number.e->u32 <= intrinsics.count_leading_zeros(number.n) {
        write_u64(number_to_u64(number));
        ret;
    }

    // Might change this to just write as float, this representation
    // is accurate, but don't know how useful it actually is
    write_u64(number.n);
    write(" * 2^");
    write_s32(number.e);
}
*/