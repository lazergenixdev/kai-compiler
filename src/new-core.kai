// #import "builtin";
// lang :: #import "common_language_semantics"
//#import "new-allocator.kai";

VERSION_STRING :: #host_import;
VERSION_MAJOR  :: #host_import;
VERSION_MINOR  :: #host_import;
VERSION_PATCH  :: #host_import;

#export version_string :: () -> string
{
    ret VERSION_STRING;
}
@doc_short ("Get version as string (includes extra version info)")

#export version :: () -> [3] u32
{
    ret {VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH};
}
@doc_short ("Get version as number (x.y.z)")

// Math

ldexp :: #host_import;

ceil_div :: (num: u64, den: u64) -> u64
{
    ret (num + den - 1) / den;
}

ceil_div_fast :: (num: u64, exp: u32) -> u64
{
    ret (num + (1 << exp) - 1) >> exp;
}

max_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret b;
    ret a;
}

min_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret a;
    ret b;
}

gcd :: (a: u64, b: u64) -> u64
{
    r: u64 = 1;
    while r != 0 {
        r = a % b;
        b = r;
        a = b;
    }
    ret r;
}

Module_Mask :: enum u32 {
    BUILTIN :: 1 << 0; // clz, ctz, popcount
    DEBUG   :: 1 << 1; // print(...), breakpoint();
    STRINGS :: 1 << 2; // concat, join, trim
}

//u128 :: struct { low: u64; high: u64; };
//Builtin :: struct {
//    u128_multiply : (a: u64, b: u64) -> u128;
//    count_leading_zeros : (a: u64) -> u32;
//}
//builtin: Builtin;

// TODO: rename + need module system ðŸ˜­
/*multiply_with_precision_loss :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    prod := builtin.u128_multiply(a, b);
    
    if prod.high == 0 {
        // Fits in 64 bits, no shift needed
        ret prod.low;
    }
    
    // Amount of right shift required to fit in 64 bits
    shift := 64 - builtin.count_leading_zeros(prod.high)->s32;
    
    if sub then [exp] -= shift;
    else        [exp] += shift;
    ret (prod.high << (64 - shift)) | (prod.low >> shift);
}*/

add_with_precision_loss :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    sum := a + b;
    carry := sum < a;
    if !carry ret sum;
    if sub then [exp] -= 1;
    else        [exp] += 1;
    ret (1 << 63) | (sum >> 1);
}

// Memory Allocator

#export Memory_Command :: enum u32 {
    ALLOCATE_WRITE_ONLY :: 0;
    SET_EXECUTABLE      :: 1;
    FREE                :: 2;
};

#export Memory_Heap_Allocate     :: #proc (user: *void, ptr: *void, new_size: u32, old_size: u32) -> *void;
#export Memory_Platform_Allocate :: #proc (user: *void, ptr: *void, size: u32, op: Memory_Command) -> *void;

Allocator :: struct {
    heap_allocate      : Memory_Heap_Allocate;
    platform_allocate  : Memory_Platform_Allocate;
    user               : *void;
    page_size          : u32;
}

// General Memory Operations

memory_copy :: (dst: *void, src: *void, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = (src->*u8)[i];
    }
}
memory_zero :: (dst: *void, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = 0;
    }
}
memory_fill :: (dst: *void, byte: u8, size: u32)
{
    for i: 0..<size {
        (dst->*u8)[i] = byte;
    }
}

// String Operations

#export string_equals :: (left: string, right: string) -> bool
{
    if left.count != right.count
        ret false;
    for i: 0..<left.count
        if left.data[i] != right.data[i]
            ret false;
    ret true;
}

#export string_from_c :: (s: *s8 @const) -> string
{
    count: u32;
    while s[count] != 0
        count += 1;
    ret {count = count, data = s->*u8};
}

#export string_from_data :: (data: *u8, count: u32) -> string
{
    ret {count = count, data = data};
}

// http://www.cse.yorku.ca/~oz/hash.html (djb2)
// " this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c.
// " another version of this algorithm (now favored by bernstein) uses xor:
// " hash(i) = hash(i - 1) * 33 ^ str[i]; the magic of number 33
// " (why it works better than many other constants, prime or not) has never been adequately explained. 

hash_string :: (s: string) -> u64
{
    hash: u64 = 5381;
    for i: 0..<s.count
        hash = ((hash << 5) + hash) + s.data[i]->u64; // hash * 33 + c
    ret hash;
}

string_hash_next :: (hash: u64, s: string) -> u64
{
    for i: 0..<s.count
        hash = ((hash << 5) + hash) + s.data[i]->u64;
    ret hash;
}

// Dynamic Arrays

#export Raw_Dynamic_Array :: struct {
    count    : u32;
    capacity : u32;
    data     : *void;
}

#export raw_array_reserve :: (array: *Raw_Dynamic_Array, allocator: *Allocator, new_capacity: u32, elem_size: u32)
{    
    if new_capacity <= array.capacity ret;
    //(array.data, new_capacity * elem_size, array.capacity * elem_size);
    //array.data = allocator.heap_allocate(allocator.user, 0, 0, 0);
    array.capacity = new_capacity;
}

#export raw_array_resize :: (array: *Raw_Dynamic_Array, new_size: u32, allocator: *Allocator, elem_size: u32)
{    
    //raw_array_reserve(array, new_size, allocator, elem_size);
    array.count = new_size;
}

#export raw_array_grow :: (array: *Raw_Dynamic_Array, count: u32, allocator: *Allocator, elem_size: u32)
{    
    if (array.count + count) <= array.capacity ret;
    n: u32 = array.count + count;
    new_capacity: u32 = max_u32(n + (n >> 1), 8);
    //raw_array_reserve(array, new_capacity, allocator, elem_size);
    new_capacity->void;
}

#export raw_array_remove :: (array: *Raw_Dynamic_Array, index: u32, elem_size: u32)
{    
    //for i: index ..< array.count - 1
    //    memory_copy(array.data->*u8 + i * elem_size, array.data->*u8 + (i+1) * elem_size, elem_size);
    array.count -= 1;
}

// Hash Table

Raw_Hash_Table :: struct {
    count      : u32;
    capacity   : u32;
    occupied   : *u64;
    hashes     : *u64;
    keys       : *string;
    values     : *void;
}

Hash_Table_Size :: struct {
    occupied : u32;
    hashes   : u32;
    keys     : u32;
    values   : u32;
    total    : u32;
}
/*
// Calculate size required for hash table
raw_hash_table_size :: (capacity: u32, elem_size: u32) -> Hash_Table_Size
{
    r: Hash_Table_Size;
    r.occupied = ceil_div_fast(capacity->u64, 6)->u32;// * #size(u64);
    r.hashes   = capacity;// * #size(u64);
    r.keys     = capacity;// * #size(string);
    r.values   = (capacity + 1) * elem_size;
    r.total    = r.occupied + r.hashes + r.keys + r.values;
    ret r;
}
*/

#export raw_hash_table_grow :: (table: *Raw_Hash_Table, allocator: *Allocator, elem_size: u32)
{
    /*
    new_capacity: u32 = _max_u32(8, table.capacity * 2);
    new_size: Hash_Table_Size = raw_hash_table_size(new_capacity, elem_size);
    new_ptr: *void = _allocate(null, new_size.total, 0);

    // Distribute allocated memory
    occupied: *u64    = new_ptr -> *u64;
    hashes:   *u64    = (occupied->*u8 + new_size.occupied) -> *u64;
    keys:     *string = (hashes->*u8 + new_size.hashes) -> *string;
    values:   *u8     = (keys->*u8 + new_size.keys) -> *u8 + elem_size;

    // Rehash all elements
    count: u32 = 0;
    for i: 0..<table.capacity
    if table.occupied[i / 64] & (1->u64 << (i % 64))
    {
        hash: u64 = string_hash(table.keys[i]);
        mask: u32 = new_capacity - 1;
        index: u32 = hash->u32 & mask;
    
        for j: 0..<new_capacity
        {
            block: u64 = occupied[index / 64];
            bit: u64 = 1->u64 << (index % 64); // are you kidding me!!
    
            // Do an insertion
            if (block & bit) == 0
            {
                occupied[index / 64] |= bit;
                hashes[index] = hash;
                keys[index] = table.keys[i];
                src: *u8 = table.values->*u8 + i * elem_size;
                _memory_copy(values + index * elem_size, src, elem_size);
                count += 1;
                break;
            }
    
            index = (index + 1) & mask;
        }
    }

    assert(count == table.count);

    // Free old memory
    if table.capacity != 0 {
        _free(table.occupied, raw_hash_table_size(table.capacity, elem_size).total);
    }

    table.capacity = new_capacity;
    table.occupied = occupied;
    table.hashes   = hashes;
    table.keys     = keys;
    table.values   = values;
    */
}

#export raw_hash_table_emplace_key :: (table: *Raw_Hash_Table, key: string, out_index: *u32, allocator: *Allocator, elem_size: u32) -> bool
{
    // Check load factor and grow hash table
 //   if 4 * table.count >= 3 * table.capacity
 //       raw_hash_table_grow(table, allocator, elem_size);

    hash := hash_string(key);
    mask := table.capacity - 1;
    index := hash->u32 & mask;

    for i: 0..<table.capacity
    {
        byte : u64 = table.occupied[index / 64];
        bit  : u64 = 1 << (index % 64);

        // Do an insertion
        if (byte & bit) == 0
        {
            table.occupied[index / 64] |= bit;
            table.hashes[index] = hash;
            table.keys[index] = key;
            table.count += 1;
            [out_index] = index;
            ret true;
        }

        // Emplace an existing item
        if table.hashes[index] == hash && string_equals(table.keys[index], key)
        {
            [out_index] = index;
            ret false;
        }

        index = (index + 1) & mask;
    }
    [out_index] = ~0;
    ret false;
}

#export raw_hash_table_find :: (table: *Raw_Hash_Table, key: string) -> s64
{
    hash := hash_string(key);
    mask := table.capacity - 1;
    index := hash->u32 & mask;

    for i: 0..<table.capacity
    {
        block : u64 = table.occupied[index / 64];
        bit   : u64 = 1 << (index % 64);

        if (block & bit) == 0
        {
            ret -1; // Slot was empty
        }
        else if table.hashes[index] == hash
             && string_equals(table.keys[index], key)
        {
            ret index->s64;
        }

        index = (index + 1) & mask;
    }
    ret -1;
}

// Errors

#export Result :: enum u32 {
    SUCCESS        :: 0;
    ERROR_MEMORY   :: 1;
    ERROR_SYNTAX   :: 2; @comment ("error from parsing")
    ERROR_TYPE     :: 3; @comment ("error from type checking")
    ERROR_SEMANTIC :: 3;
    ERROR_INFO     :: 4;
    ERROR_FATAL    :: 5; @comment ("means compiler bug probably")
    ERROR_INTERNAL :: 6; @comment ("means compiler error unrelated to the source code")
    RESULT_COUNT   :: 7;
}

#export Source :: struct {
    name:     string;
    contents: string;
}

#export Location :: struct {
    source : Source; // source code for this file
    string : string;
    line   : u32;
}

#export Error :: struct {
    result   : Result;
    location : Location;
    message  : string;
    context  : string;
    next     : *Error;
}

// Type Info

#export Type_Id :: enum u8 {
    TYPE      :: 0; @comment ("no type info struct")
    VOID      :: 1; @comment ("no type info struct")
    BOOLEAN   :: 2; @comment ("no type info struct")
    INTEGER   :: 3;
    FLOAT     :: 4;
    POINTER   :: 5;
    PROCEDURE :: 6;
    ARRAY     :: 7;
    STRUCT    :: 8;
    ENUM      :: 9;
    STRING    :: 10; @comment ("same as STRUCT")
    NUMBER    :: 11; @comment ("compiler internal only")
} @long_names

#export Type :: *Type_Info;

#export Type_Info :: struct {
    id : Type_Id;
}

#export Type_Info_Integer :: struct {
    //using Type_Info;
    is_signed : bool;
    bits : u8;
}

// Numbers

Number :: struct {
    n: u64;
    d: u64; @comment ("never 0 (except when n == 0)")
    e: s32;
    is_neg: bool;
}
@doc_short ("Number type used for number literals")

number_to_u64 :: (number: Number) -> u64
{
    ret number.n << number.e;
}
@doc_warning ("number must be normalized")

number_to_f64 :: (number: Number) -> f64
{
    if number.n == 0 ret 0.0;
    val := number.n->f64 / number.d->f64;
    if number.is_neg then
        val = -val;
    ret ldexp(val, number.e);
}
/*/*
number_normalize :: (number: Number) -> Number
{
    if number.n == 0 ret Number.{};
    ns: s32 = intrinsics_ctz64(number.n);
    ds: s32 = intrinsics_ctz64(number.d);
    ex: s32 = number.e + (ns - ds);
    nu: u64 = number.n >> ns;
    de: u64 = number.d >> ds;
    cd: u64 = _gcd(nu, de);
    ret Number.{
        n = nu / cd,
        d = de / cd,
        e = ex,
        is_neg = number.is_neg,
    };
}
*/
number_neg :: (a: Number) -> Number
{
    ret {n = a.n, d = a.d, e = a.e, is_neg = a.is_neg ^ 1};
}

number_abs :: (a: Number) -> Number
{
    ret {n = a.n, d = a.d, e = a.e, is_neg = 0};
}

number_inv :: (a: Number) -> Number
{
    ret {n = a.d, d = a.n, e = -a.e, is_neg = a.is_neg};
}

number_add :: (a: Number, b: Number) -> Number
{
    /*
    if a.n == 0 ret b;
    if b.n == 0 ret a;

    if a.e == b.e
        ret number_add_same_exp(a, b);

    number_match_exponents(*a, *b);
    ret number_add_same_exp(a, b);
    */
}

number_sub :: (a: Number, b: Number) -> Number
{
    ret number_add(a, number_neg(b));
}

// ...

number_add_same_exp :: (a: Number, b: Number) -> Number
{
    /*
    t0e: s32 = 0;
    t1e: s32 = 0;
    t0: u64 = multiply_with_precision_loss(a.n, b.d, *t0e, 0);
    t1: u64 = multiply_with_precision_loss(b.n, a.d, *t1e, 0);
    ex: s32 = a.e;

    // Exponents have changed, need to make them the same again
    if t0e != t1e {
        if (t0e < t1e) {
            t0 = t0 >> (t1e - t0e);
            ex += t1e;
        }
        else {
            t1 = t1 >> (t0e - t1e);
            ex += t0e;
        }
    }

    de: u64 = multiply_with_precision_loss(a.d, b.d, *ex, 1);
    nu: u64;

    // Handle resulting sign
    is_neg: u32 = a.is_neg & b.is_neg;
    if a.is_neg && !b.is_neg {
        if t0 > t1 { nu = t0 - t1; is_neg = 1; } // -5 + 1
        else       { nu = t1 - t0; is_neg = 0; } // -1 + 5
    }
    else if b.is_neg && !a.is_neg {
        if t0 > t1 { nu = t0 - t1; is_neg = 0; } // 5 + -1
        else       { nu = t1 - t0; is_neg = 1; } // 1 + -5
    }
    else {
        nu = add_with_shift(t0, t1, *ex, 0);
    }

    ret number_normalize(Number.{
        n = nu, d = de, e = ex,
        is_neg = is_neg,
    });
    */
}

number_match_exponents :: (a: *Number, b: *Number)
{
    /*
    if a.e < b.e {
        // reduce b.e or increase a.e
        while a.e != b.e && (a.d >> 63) == 0 {
            a.d = a.d << 1;
            a.e += 1;
        }
        while a.e != b.e && (b.n >> 63) == 0 {
            b.n = b.n << 1;
            b.e -= 1;
        }
        // must lose some precision now :(
        diff: s64 = b.e - a.e;
        a.n = a.n >> diff->u32;
        a.e = b.e;
    }
    else /* a.e > b.e */ {
        // reduce a.e or increase b.e
        while (a.e != b.e && (b.d >> 63) == 0) {
            b.d = b.d << 1;
            b.e += 1;
        }
        while (a.e != b.e && (a.n >> 63) == 0) {
            a.n = a.n << 1;
            a.e -= 1;
        }
        // must lose some precision now :(
        diff: s64 = a.e - b.e;
        b.n = b.n >> diff->u32;
        b.e = a.e;
    }
    */
}
*/

/*
write_number :: (writer: *Writer, number: Number)
{
    // If number is a fraction, write it out as a float
    if !number_is_integer(number) {
        write_f64(number_to_f64(number));
        ret;
    }

    if number.is_neg {
        write("-");
    }

    // If number fits into u64, write it out as u64
    if number.e->u32 <= intrinsics.count_leading_zeros(number.n) {
        write_u64(number_to_u64(number));
        ret;
    }

    // Might change this to just write as float, this representation
    // is accurate, but don't know how useful it actually is
    write_u64(number.n);
    write(" * 2^");
    write_s32(number.e);
}
*/