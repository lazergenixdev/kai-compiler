// c :: #import "ctypes";

VERSION_STRING :: #host_import;
VERSION_MAJOR  :: #host_import;
VERSION_MINOR  :: #host_import;
VERSION_PATCH  :: #host_import;

cstring :: *s8 @const;

#export version_string :: () -> string
{
    ret VERSION_STRING;
}
@doc_short ("Get version as string (includes extra version info)")

#export version :: () -> [3] u32
{
    ret {VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH};
}
@doc_short ("Get version as number")

// Math

ceil_div :: (num: u64, den: u64) -> u64
{
    ret (num + den - 1) / den;
}
ceil_div_fast :: (num: u64, exp: u32) -> u64
{
    ret (num + (1 << exp) - 1) >> exp;
}
max_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret b;
    ret a;
}
min_u32 :: (a: u32, b: u32) -> u32
{
    if a < b ret a;
    ret b;
}
gcd :: (a: u64, b: u64) -> u64
{
    r: u64 = 1;
    while r != 0 {
        r = a % b;
        b = r;
        a = b;
    }
    ret r;
}
//ldexp :: #host_import;

// ...

add_with_shift :: (a: u64, b: u64, exp: *s32, sub: bool) -> u64
{
    sum := a + b;
    carry := sum < a;

    if !carry ret sum;

    if sub then
        [exp] -= 1;
    else
        [exp] += 1;
    ret (1 << 63) | (sum >> 1);
}

// Memory Allocator

#export Memory_Command :: enum u32 {
    ALLOCATE_WRITE_ONLY :: 0;
    SET_EXECUTABLE      :: 1;
    FREE                :: 2;
};

#export P_Memory_Heap_Allocate     :: #proc (user: *void, ptr: *void, new_size: u32, old_size: u32) -> *void;
#export P_Memory_Platform_Allocate :: #proc (user: *void, ptr: *void, size: u32, op: Memory_Command) -> *void;

Allocator :: struct {
    heap_allocate      : *P_Memory_Heap_Allocate;
    platform_allocate  : *P_Memory_Platform_Allocate;
    user               : *void;
    page_size          : u32;
}

// General Memory Operations

#export Memory :: struct {
    data : *void;
    size : u32;
}

memory_copy :: (dst: *void, src: *void, size: u32)
{
    //for i: 0..<size {
    //    (dst->*u8)[i] = (src->*u8)[i];
    //}
}
memory_zero :: (dst: *void, size: u32)
{
    //for i: 0..<size {
    //    (dst->*u8)[i] = 0;
    //}
}
memory_fill :: (dst: *void, byte: u8, size: u32)
{
    //for i: 0..<size {
    //    (dst->*u8)[i] = byte;
    //}
}

// String Operations

#export string_equals :: (left: string, right: string) -> bool
{
    if left.count != right.count ret false;
    //for i: 0..<left.count {
    //    if left.data[i] != right.data[i] ret false;
    //}
    ret true;
}

#export string_from_c :: (s: cstring) -> string
{
    count: u32;
    //while (s[count] != 0) count += 1;
    ret {count = count, data = s->*u8};
}

#export string_from_data :: (data: *u8, count: u32) -> string
{
    ret {count = count, data = data};
}

// http://www.cse.yorku.ca/~oz/hash.html (djb2)
// " this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c.
// " another version of this algorithm (now favored by bernstein) uses xor:
// " hash(i) = hash(i - 1) * 33 ^ str[i]; the magic of number 33
// " (why it works better than many other constants, prime or not) has never been adequately explained. 

string_hash :: (s: string) -> u64
{
    hash: u64 = 5381;
    //for i: 0..<s.count
    //    hash = ((hash << 5) + hash) + s.data[i]; // hash * 33 + c
    ret hash;
}
string_hash_next :: (hash: u64, s: string) -> u64
{
    //for i: 0..<s.count
    //    hash = ((hash << 5) + hash) + s.data[i];
    ret hash;
}

// Dynamic Arrays

#export Raw_Dynamic_Array :: struct {
    count    : u32;
    capacity : u32;
    data     : *void;
}

#export raw_array_reserve :: (array: *Raw_Dynamic_Array, allocator: *Allocator, new_capacity: u32, elem_size: u32)
{    
    if new_capacity <= array.capacity ret;
    //array.data = _allocate(array.data, new_capacity * elem_size, array.capacity * elem_size);
    //array.data = null;
    array.capacity = new_capacity;
}

#export Type_Info :: struct {
    id : Type_Id;
}

// Errors

#export Result :: enum u32 {
    SUCCESS        :: 0;
    ERROR_MEMORY   :: 1;
    ERROR_SYNTAX   :: 2; @comment ("error from parsing")
    ERROR_TYPE     :: 3; @comment ("error from type checking")
    ERROR_SEMANTIC :: 3;
    ERROR_INFO     :: 4;
    ERROR_FATAL    :: 5; @comment ("means compiler bug probably")
    ERROR_INTERNAL :: 6; @comment ("means compiler error unrelated to the source code")
    RESULT_COUNT   :: 7;
}

#export Source :: struct {
    name:     string;
    contents: string;
}

#export Location :: struct {
    source : Source; // source code for this file
    string : string;
    line   : u32;
}

#export Error :: struct {
    result   : Result;
    location : Location;
    message  : string;
    context  : string;
    memory   : Memory;
    next     : *Error;
}

// Type Info

#export Type_Id :: enum u8 {
    TYPE      :: 0; @comment ("no type info struct")
    VOID      :: 1; @comment ("no type info struct")
    BOOLEAN   :: 2; @comment ("no type info struct")
    INTEGER   :: 3;
    FLOAT     :: 4;
    POINTER   :: 5;
    PROCEDURE :: 6;
    ARRAY     :: 7;
    STRUCT    :: 8;
    ENUM      :: 9;
    STRING    :: 10; @comment ("same as STRUCT")
    NUMBER    :: 11; @comment ("compiler internal only")
} @long_names

#export Type :: *Type_Info;
